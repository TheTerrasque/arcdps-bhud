// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `eventdata.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct ImGuiEvent {
    // message fields
    pub UiState: UiState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImGuiEvent {
    fn default() -> &'a ImGuiEvent {
        <ImGuiEvent as ::protobuf::Message>::default_instance()
    }
}

impl ImGuiEvent {
    pub fn new() -> ImGuiEvent {
        ::std::default::Default::default()
    }

    // .UiState UiState = 1;


    pub fn get_UiState(&self) -> UiState {
        self.UiState
    }
    pub fn clear_UiState(&mut self) {
        self.UiState = UiState::Default;
    }

    // Param is passed by value, moved
    pub fn set_UiState(&mut self, v: UiState) {
        self.UiState = v;
    }
}

impl ::protobuf::Message for ImGuiEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.UiState, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.UiState != UiState::Default {
            my_size += ::protobuf::rt::enum_size(1, self.UiState);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.UiState != UiState::Default {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.UiState))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImGuiEvent {
        ImGuiEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UiState>>(
                "UiState",
                |m: &ImGuiEvent| { &m.UiState },
                |m: &mut ImGuiEvent| { &mut m.UiState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImGuiEvent>(
                "ImGuiEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImGuiEvent {
        static instance: ::protobuf::rt::LazyV2<ImGuiEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImGuiEvent::new)
    }
}

impl ::protobuf::Clear for ImGuiEvent {
    fn clear(&mut self) {
        self.UiState = UiState::Default;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImGuiEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImGuiEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Actor {
    // message fields
    pub name: ::std::string::String,
    pub id: u32,
    pub Profession: u32,
    pub EliteSpec: u32,
    pub is_player: bool,
    pub team: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Actor {
    fn default() -> &'a Actor {
        <Actor as ::protobuf::Message>::default_instance()
    }
}

impl Actor {
    pub fn new() -> Actor {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 id = 2;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // uint32 Profession = 3;


    pub fn get_Profession(&self) -> u32 {
        self.Profession
    }
    pub fn clear_Profession(&mut self) {
        self.Profession = 0;
    }

    // Param is passed by value, moved
    pub fn set_Profession(&mut self, v: u32) {
        self.Profession = v;
    }

    // uint32 EliteSpec = 4;


    pub fn get_EliteSpec(&self) -> u32 {
        self.EliteSpec
    }
    pub fn clear_EliteSpec(&mut self) {
        self.EliteSpec = 0;
    }

    // Param is passed by value, moved
    pub fn set_EliteSpec(&mut self, v: u32) {
        self.EliteSpec = v;
    }

    // bool is_player = 5;


    pub fn get_is_player(&self) -> bool {
        self.is_player
    }
    pub fn clear_is_player(&mut self) {
        self.is_player = false;
    }

    // Param is passed by value, moved
    pub fn set_is_player(&mut self, v: bool) {
        self.is_player = v;
    }

    // uint32 team = 6;


    pub fn get_team(&self) -> u32 {
        self.team
    }
    pub fn clear_team(&mut self) {
        self.team = 0;
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = v;
    }
}

impl ::protobuf::Message for Actor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Profession = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.EliteSpec = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_player = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Profession != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Profession, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EliteSpec != 0 {
            my_size += ::protobuf::rt::value_size(4, self.EliteSpec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_player != false {
            my_size += 2;
        }
        if self.team != 0 {
            my_size += ::protobuf::rt::value_size(6, self.team, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.id != 0 {
            os.write_uint32(2, self.id)?;
        }
        if self.Profession != 0 {
            os.write_uint32(3, self.Profession)?;
        }
        if self.EliteSpec != 0 {
            os.write_uint32(4, self.EliteSpec)?;
        }
        if self.is_player != false {
            os.write_bool(5, self.is_player)?;
        }
        if self.team != 0 {
            os.write_uint32(6, self.team)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Actor {
        Actor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Actor| { &m.name },
                |m: &mut Actor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Actor| { &m.id },
                |m: &mut Actor| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Profession",
                |m: &Actor| { &m.Profession },
                |m: &mut Actor| { &mut m.Profession },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "EliteSpec",
                |m: &Actor| { &m.EliteSpec },
                |m: &mut Actor| { &mut m.EliteSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_player",
                |m: &Actor| { &m.is_player },
                |m: &mut Actor| { &mut m.is_player },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "team",
                |m: &Actor| { &m.team },
                |m: &mut Actor| { &mut m.team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Actor>(
                "Actor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Actor {
        static instance: ::protobuf::rt::LazyV2<Actor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Actor::new)
    }
}

impl ::protobuf::Clear for Actor {
    fn clear(&mut self) {
        self.name.clear();
        self.id = 0;
        self.Profession = 0;
        self.EliteSpec = 0;
        self.is_player = false;
        self.team = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Actor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Actor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CombatEvent {
    // message fields
    pub time: u64,
    pub damage: i32,
    pub shield_damage: u32,
    pub skillid: u32,
    pub src_instid: u32,
    pub dst_instid: u32,
    pub src_master_instid: u32,
    pub friend_or_foe: Affinity,
    pub result: CombatResult,
    pub activation: CombatActivation,
    pub buffremove: BuffRemoveType,
    pub src_hp_over_90: bool,
    pub dst_hp_over_50: bool,
    pub src_is_moving: bool,
    pub statechange: StateChange,
    pub is_flanking: bool,
    pub buff_added_active: bool,
    pub is_offcycle: u32,
    pub pad61: u32,
    pub pad62: u32,
    pub pad63: u32,
    pub pad64: u32,
    pub target_downed: bool,
    pub buff_stacks_removed: i32,
    pub buff_duration: i32,
    pub tag_id: u32,
    pub buff_stackid: u32,
    pub new_team_id: u32,
    pub reward_id: u32,
    pub reward_type: u32,
    pub weapon_set: WeaponSet,
    pub time_in_animation: u32,
    pub time_in_animation_scaled: u32,
    pub EventType: EventType,
    pub buff_damage_result: BuffDamageResult,
    pub buff_type: BuffType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CombatEvent {
    fn default() -> &'a CombatEvent {
        <CombatEvent as ::protobuf::Message>::default_instance()
    }
}

impl CombatEvent {
    pub fn new() -> CombatEvent {
        ::std::default::Default::default()
    }

    // uint64 time = 1;


    pub fn get_time(&self) -> u64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u64) {
        self.time = v;
    }

    // int32 damage = 4;


    pub fn get_damage(&self) -> i32 {
        self.damage
    }
    pub fn clear_damage(&mut self) {
        self.damage = 0;
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: i32) {
        self.damage = v;
    }

    // uint32 shield_damage = 6;


    pub fn get_shield_damage(&self) -> u32 {
        self.shield_damage
    }
    pub fn clear_shield_damage(&mut self) {
        self.shield_damage = 0;
    }

    // Param is passed by value, moved
    pub fn set_shield_damage(&mut self, v: u32) {
        self.shield_damage = v;
    }

    // uint32 skillid = 7;


    pub fn get_skillid(&self) -> u32 {
        self.skillid
    }
    pub fn clear_skillid(&mut self) {
        self.skillid = 0;
    }

    // Param is passed by value, moved
    pub fn set_skillid(&mut self, v: u32) {
        self.skillid = v;
    }

    // uint32 src_instid = 8;


    pub fn get_src_instid(&self) -> u32 {
        self.src_instid
    }
    pub fn clear_src_instid(&mut self) {
        self.src_instid = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_instid(&mut self, v: u32) {
        self.src_instid = v;
    }

    // uint32 dst_instid = 9;


    pub fn get_dst_instid(&self) -> u32 {
        self.dst_instid
    }
    pub fn clear_dst_instid(&mut self) {
        self.dst_instid = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_instid(&mut self, v: u32) {
        self.dst_instid = v;
    }

    // uint32 src_master_instid = 10;


    pub fn get_src_master_instid(&self) -> u32 {
        self.src_master_instid
    }
    pub fn clear_src_master_instid(&mut self) {
        self.src_master_instid = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_master_instid(&mut self, v: u32) {
        self.src_master_instid = v;
    }

    // .Affinity friend_or_foe = 11;


    pub fn get_friend_or_foe(&self) -> Affinity {
        self.friend_or_foe
    }
    pub fn clear_friend_or_foe(&mut self) {
        self.friend_or_foe = Affinity::AF_Unparsed;
    }

    // Param is passed by value, moved
    pub fn set_friend_or_foe(&mut self, v: Affinity) {
        self.friend_or_foe = v;
    }

    // .CombatResult result = 13;


    pub fn get_result(&self) -> CombatResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CombatResult::Normal;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CombatResult) {
        self.result = v;
    }

    // .CombatActivation activation = 14;


    pub fn get_activation(&self) -> CombatActivation {
        self.activation
    }
    pub fn clear_activation(&mut self) {
        self.activation = CombatActivation::CA_NONE;
    }

    // Param is passed by value, moved
    pub fn set_activation(&mut self, v: CombatActivation) {
        self.activation = v;
    }

    // .BuffRemoveType buffremove = 15;


    pub fn get_buffremove(&self) -> BuffRemoveType {
        self.buffremove
    }
    pub fn clear_buffremove(&mut self) {
        self.buffremove = BuffRemoveType::BR_None;
    }

    // Param is passed by value, moved
    pub fn set_buffremove(&mut self, v: BuffRemoveType) {
        self.buffremove = v;
    }

    // bool src_hp_over_90 = 16;


    pub fn get_src_hp_over_90(&self) -> bool {
        self.src_hp_over_90
    }
    pub fn clear_src_hp_over_90(&mut self) {
        self.src_hp_over_90 = false;
    }

    // Param is passed by value, moved
    pub fn set_src_hp_over_90(&mut self, v: bool) {
        self.src_hp_over_90 = v;
    }

    // bool dst_hp_over_50 = 17;


    pub fn get_dst_hp_over_50(&self) -> bool {
        self.dst_hp_over_50
    }
    pub fn clear_dst_hp_over_50(&mut self) {
        self.dst_hp_over_50 = false;
    }

    // Param is passed by value, moved
    pub fn set_dst_hp_over_50(&mut self, v: bool) {
        self.dst_hp_over_50 = v;
    }

    // bool src_is_moving = 18;


    pub fn get_src_is_moving(&self) -> bool {
        self.src_is_moving
    }
    pub fn clear_src_is_moving(&mut self) {
        self.src_is_moving = false;
    }

    // Param is passed by value, moved
    pub fn set_src_is_moving(&mut self, v: bool) {
        self.src_is_moving = v;
    }

    // .StateChange statechange = 19;


    pub fn get_statechange(&self) -> StateChange {
        self.statechange
    }
    pub fn clear_statechange(&mut self) {
        self.statechange = StateChange::NONE;
    }

    // Param is passed by value, moved
    pub fn set_statechange(&mut self, v: StateChange) {
        self.statechange = v;
    }

    // bool is_flanking = 20;


    pub fn get_is_flanking(&self) -> bool {
        self.is_flanking
    }
    pub fn clear_is_flanking(&mut self) {
        self.is_flanking = false;
    }

    // Param is passed by value, moved
    pub fn set_is_flanking(&mut self, v: bool) {
        self.is_flanking = v;
    }

    // bool buff_added_active = 21;


    pub fn get_buff_added_active(&self) -> bool {
        self.buff_added_active
    }
    pub fn clear_buff_added_active(&mut self) {
        self.buff_added_active = false;
    }

    // Param is passed by value, moved
    pub fn set_buff_added_active(&mut self, v: bool) {
        self.buff_added_active = v;
    }

    // uint32 is_offcycle = 22;


    pub fn get_is_offcycle(&self) -> u32 {
        self.is_offcycle
    }
    pub fn clear_is_offcycle(&mut self) {
        self.is_offcycle = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_offcycle(&mut self, v: u32) {
        self.is_offcycle = v;
    }

    // uint32 pad61 = 23;


    pub fn get_pad61(&self) -> u32 {
        self.pad61
    }
    pub fn clear_pad61(&mut self) {
        self.pad61 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad61(&mut self, v: u32) {
        self.pad61 = v;
    }

    // uint32 pad62 = 24;


    pub fn get_pad62(&self) -> u32 {
        self.pad62
    }
    pub fn clear_pad62(&mut self) {
        self.pad62 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad62(&mut self, v: u32) {
        self.pad62 = v;
    }

    // uint32 pad63 = 25;


    pub fn get_pad63(&self) -> u32 {
        self.pad63
    }
    pub fn clear_pad63(&mut self) {
        self.pad63 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad63(&mut self, v: u32) {
        self.pad63 = v;
    }

    // uint32 pad64 = 26;


    pub fn get_pad64(&self) -> u32 {
        self.pad64
    }
    pub fn clear_pad64(&mut self) {
        self.pad64 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad64(&mut self, v: u32) {
        self.pad64 = v;
    }

    // bool target_downed = 27;


    pub fn get_target_downed(&self) -> bool {
        self.target_downed
    }
    pub fn clear_target_downed(&mut self) {
        self.target_downed = false;
    }

    // Param is passed by value, moved
    pub fn set_target_downed(&mut self, v: bool) {
        self.target_downed = v;
    }

    // int32 buff_stacks_removed = 28;


    pub fn get_buff_stacks_removed(&self) -> i32 {
        self.buff_stacks_removed
    }
    pub fn clear_buff_stacks_removed(&mut self) {
        self.buff_stacks_removed = 0;
    }

    // Param is passed by value, moved
    pub fn set_buff_stacks_removed(&mut self, v: i32) {
        self.buff_stacks_removed = v;
    }

    // int32 buff_duration = 29;


    pub fn get_buff_duration(&self) -> i32 {
        self.buff_duration
    }
    pub fn clear_buff_duration(&mut self) {
        self.buff_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_buff_duration(&mut self, v: i32) {
        self.buff_duration = v;
    }

    // uint32 tag_id = 30;


    pub fn get_tag_id(&self) -> u32 {
        self.tag_id
    }
    pub fn clear_tag_id(&mut self) {
        self.tag_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag_id(&mut self, v: u32) {
        self.tag_id = v;
    }

    // uint32 buff_stackid = 31;


    pub fn get_buff_stackid(&self) -> u32 {
        self.buff_stackid
    }
    pub fn clear_buff_stackid(&mut self) {
        self.buff_stackid = 0;
    }

    // Param is passed by value, moved
    pub fn set_buff_stackid(&mut self, v: u32) {
        self.buff_stackid = v;
    }

    // uint32 new_team_id = 32;


    pub fn get_new_team_id(&self) -> u32 {
        self.new_team_id
    }
    pub fn clear_new_team_id(&mut self) {
        self.new_team_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_team_id(&mut self, v: u32) {
        self.new_team_id = v;
    }

    // uint32 reward_id = 33;


    pub fn get_reward_id(&self) -> u32 {
        self.reward_id
    }
    pub fn clear_reward_id(&mut self) {
        self.reward_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_reward_id(&mut self, v: u32) {
        self.reward_id = v;
    }

    // uint32 reward_type = 34;


    pub fn get_reward_type(&self) -> u32 {
        self.reward_type
    }
    pub fn clear_reward_type(&mut self) {
        self.reward_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_reward_type(&mut self, v: u32) {
        self.reward_type = v;
    }

    // .WeaponSet weapon_set = 35;


    pub fn get_weapon_set(&self) -> WeaponSet {
        self.weapon_set
    }
    pub fn clear_weapon_set(&mut self) {
        self.weapon_set = WeaponSet::WS_Unparsed;
    }

    // Param is passed by value, moved
    pub fn set_weapon_set(&mut self, v: WeaponSet) {
        self.weapon_set = v;
    }

    // uint32 time_in_animation = 36;


    pub fn get_time_in_animation(&self) -> u32 {
        self.time_in_animation
    }
    pub fn clear_time_in_animation(&mut self) {
        self.time_in_animation = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_in_animation(&mut self, v: u32) {
        self.time_in_animation = v;
    }

    // uint32 time_in_animation_scaled = 37;


    pub fn get_time_in_animation_scaled(&self) -> u32 {
        self.time_in_animation_scaled
    }
    pub fn clear_time_in_animation_scaled(&mut self) {
        self.time_in_animation_scaled = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_in_animation_scaled(&mut self, v: u32) {
        self.time_in_animation_scaled = v;
    }

    // .EventType EventType = 38;


    pub fn get_EventType(&self) -> EventType {
        self.EventType
    }
    pub fn clear_EventType(&mut self) {
        self.EventType = EventType::None;
    }

    // Param is passed by value, moved
    pub fn set_EventType(&mut self, v: EventType) {
        self.EventType = v;
    }

    // .BuffDamageResult buff_damage_result = 39;


    pub fn get_buff_damage_result(&self) -> BuffDamageResult {
        self.buff_damage_result
    }
    pub fn clear_buff_damage_result(&mut self) {
        self.buff_damage_result = BuffDamageResult::BD_Unparsed;
    }

    // Param is passed by value, moved
    pub fn set_buff_damage_result(&mut self, v: BuffDamageResult) {
        self.buff_damage_result = v;
    }

    // .BuffType buff_type = 40;


    pub fn get_buff_type(&self) -> BuffType {
        self.buff_type
    }
    pub fn clear_buff_type(&mut self) {
        self.buff_type = BuffType::BT_NONE;
    }

    // Param is passed by value, moved
    pub fn set_buff_type(&mut self, v: BuffType) {
        self.buff_type = v;
    }
}

impl ::protobuf::Message for CombatEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.damage = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shield_damage = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.skillid = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_instid = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_instid = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_master_instid = tmp;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.friend_or_foe, 11, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.activation, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.buffremove, 15, &mut self.unknown_fields)?
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.src_hp_over_90 = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dst_hp_over_50 = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.src_is_moving = tmp;
                },
                19 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.statechange, 19, &mut self.unknown_fields)?
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_flanking = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.buff_added_active = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_offcycle = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad61 = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad62 = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad63 = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad64 = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.target_downed = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buff_stacks_removed = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buff_duration = tmp;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tag_id = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buff_stackid = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_team_id = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_id = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_type = tmp;
                },
                35 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.weapon_set, 35, &mut self.unknown_fields)?
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_in_animation = tmp;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_in_animation_scaled = tmp;
                },
                38 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.EventType, 38, &mut self.unknown_fields)?
                },
                39 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.buff_damage_result, 39, &mut self.unknown_fields)?
                },
                40 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.buff_type, 40, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.damage != 0 {
            my_size += ::protobuf::rt::value_size(4, self.damage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shield_damage != 0 {
            my_size += ::protobuf::rt::value_size(6, self.shield_damage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.skillid != 0 {
            my_size += ::protobuf::rt::value_size(7, self.skillid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_instid != 0 {
            my_size += ::protobuf::rt::value_size(8, self.src_instid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_instid != 0 {
            my_size += ::protobuf::rt::value_size(9, self.dst_instid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_master_instid != 0 {
            my_size += ::protobuf::rt::value_size(10, self.src_master_instid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.friend_or_foe != Affinity::AF_Unparsed {
            my_size += ::protobuf::rt::enum_size(11, self.friend_or_foe);
        }
        if self.result != CombatResult::Normal {
            my_size += ::protobuf::rt::enum_size(13, self.result);
        }
        if self.activation != CombatActivation::CA_NONE {
            my_size += ::protobuf::rt::enum_size(14, self.activation);
        }
        if self.buffremove != BuffRemoveType::BR_None {
            my_size += ::protobuf::rt::enum_size(15, self.buffremove);
        }
        if self.src_hp_over_90 != false {
            my_size += 3;
        }
        if self.dst_hp_over_50 != false {
            my_size += 3;
        }
        if self.src_is_moving != false {
            my_size += 3;
        }
        if self.statechange != StateChange::NONE {
            my_size += ::protobuf::rt::enum_size(19, self.statechange);
        }
        if self.is_flanking != false {
            my_size += 3;
        }
        if self.buff_added_active != false {
            my_size += 3;
        }
        if self.is_offcycle != 0 {
            my_size += ::protobuf::rt::value_size(22, self.is_offcycle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad61 != 0 {
            my_size += ::protobuf::rt::value_size(23, self.pad61, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad62 != 0 {
            my_size += ::protobuf::rt::value_size(24, self.pad62, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad63 != 0 {
            my_size += ::protobuf::rt::value_size(25, self.pad63, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad64 != 0 {
            my_size += ::protobuf::rt::value_size(26, self.pad64, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_downed != false {
            my_size += 3;
        }
        if self.buff_stacks_removed != 0 {
            my_size += ::protobuf::rt::value_size(28, self.buff_stacks_removed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.buff_duration != 0 {
            my_size += ::protobuf::rt::value_size(29, self.buff_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tag_id != 0 {
            my_size += ::protobuf::rt::value_size(30, self.tag_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.buff_stackid != 0 {
            my_size += ::protobuf::rt::value_size(31, self.buff_stackid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.new_team_id != 0 {
            my_size += ::protobuf::rt::value_size(32, self.new_team_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reward_id != 0 {
            my_size += ::protobuf::rt::value_size(33, self.reward_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reward_type != 0 {
            my_size += ::protobuf::rt::value_size(34, self.reward_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.weapon_set != WeaponSet::WS_Unparsed {
            my_size += ::protobuf::rt::enum_size(35, self.weapon_set);
        }
        if self.time_in_animation != 0 {
            my_size += ::protobuf::rt::value_size(36, self.time_in_animation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_in_animation_scaled != 0 {
            my_size += ::protobuf::rt::value_size(37, self.time_in_animation_scaled, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EventType != EventType::None {
            my_size += ::protobuf::rt::enum_size(38, self.EventType);
        }
        if self.buff_damage_result != BuffDamageResult::BD_Unparsed {
            my_size += ::protobuf::rt::enum_size(39, self.buff_damage_result);
        }
        if self.buff_type != BuffType::BT_NONE {
            my_size += ::protobuf::rt::enum_size(40, self.buff_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0 {
            os.write_uint64(1, self.time)?;
        }
        if self.damage != 0 {
            os.write_int32(4, self.damage)?;
        }
        if self.shield_damage != 0 {
            os.write_uint32(6, self.shield_damage)?;
        }
        if self.skillid != 0 {
            os.write_uint32(7, self.skillid)?;
        }
        if self.src_instid != 0 {
            os.write_uint32(8, self.src_instid)?;
        }
        if self.dst_instid != 0 {
            os.write_uint32(9, self.dst_instid)?;
        }
        if self.src_master_instid != 0 {
            os.write_uint32(10, self.src_master_instid)?;
        }
        if self.friend_or_foe != Affinity::AF_Unparsed {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.friend_or_foe))?;
        }
        if self.result != CombatResult::Normal {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if self.activation != CombatActivation::CA_NONE {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.activation))?;
        }
        if self.buffremove != BuffRemoveType::BR_None {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&self.buffremove))?;
        }
        if self.src_hp_over_90 != false {
            os.write_bool(16, self.src_hp_over_90)?;
        }
        if self.dst_hp_over_50 != false {
            os.write_bool(17, self.dst_hp_over_50)?;
        }
        if self.src_is_moving != false {
            os.write_bool(18, self.src_is_moving)?;
        }
        if self.statechange != StateChange::NONE {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&self.statechange))?;
        }
        if self.is_flanking != false {
            os.write_bool(20, self.is_flanking)?;
        }
        if self.buff_added_active != false {
            os.write_bool(21, self.buff_added_active)?;
        }
        if self.is_offcycle != 0 {
            os.write_uint32(22, self.is_offcycle)?;
        }
        if self.pad61 != 0 {
            os.write_uint32(23, self.pad61)?;
        }
        if self.pad62 != 0 {
            os.write_uint32(24, self.pad62)?;
        }
        if self.pad63 != 0 {
            os.write_uint32(25, self.pad63)?;
        }
        if self.pad64 != 0 {
            os.write_uint32(26, self.pad64)?;
        }
        if self.target_downed != false {
            os.write_bool(27, self.target_downed)?;
        }
        if self.buff_stacks_removed != 0 {
            os.write_int32(28, self.buff_stacks_removed)?;
        }
        if self.buff_duration != 0 {
            os.write_int32(29, self.buff_duration)?;
        }
        if self.tag_id != 0 {
            os.write_uint32(30, self.tag_id)?;
        }
        if self.buff_stackid != 0 {
            os.write_uint32(31, self.buff_stackid)?;
        }
        if self.new_team_id != 0 {
            os.write_uint32(32, self.new_team_id)?;
        }
        if self.reward_id != 0 {
            os.write_uint32(33, self.reward_id)?;
        }
        if self.reward_type != 0 {
            os.write_uint32(34, self.reward_type)?;
        }
        if self.weapon_set != WeaponSet::WS_Unparsed {
            os.write_enum(35, ::protobuf::ProtobufEnum::value(&self.weapon_set))?;
        }
        if self.time_in_animation != 0 {
            os.write_uint32(36, self.time_in_animation)?;
        }
        if self.time_in_animation_scaled != 0 {
            os.write_uint32(37, self.time_in_animation_scaled)?;
        }
        if self.EventType != EventType::None {
            os.write_enum(38, ::protobuf::ProtobufEnum::value(&self.EventType))?;
        }
        if self.buff_damage_result != BuffDamageResult::BD_Unparsed {
            os.write_enum(39, ::protobuf::ProtobufEnum::value(&self.buff_damage_result))?;
        }
        if self.buff_type != BuffType::BT_NONE {
            os.write_enum(40, ::protobuf::ProtobufEnum::value(&self.buff_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CombatEvent {
        CombatEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "time",
                |m: &CombatEvent| { &m.time },
                |m: &mut CombatEvent| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "damage",
                |m: &CombatEvent| { &m.damage },
                |m: &mut CombatEvent| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shield_damage",
                |m: &CombatEvent| { &m.shield_damage },
                |m: &mut CombatEvent| { &mut m.shield_damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "skillid",
                |m: &CombatEvent| { &m.skillid },
                |m: &mut CombatEvent| { &mut m.skillid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "src_instid",
                |m: &CombatEvent| { &m.src_instid },
                |m: &mut CombatEvent| { &mut m.src_instid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dst_instid",
                |m: &CombatEvent| { &m.dst_instid },
                |m: &mut CombatEvent| { &mut m.dst_instid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "src_master_instid",
                |m: &CombatEvent| { &m.src_master_instid },
                |m: &mut CombatEvent| { &mut m.src_master_instid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Affinity>>(
                "friend_or_foe",
                |m: &CombatEvent| { &m.friend_or_foe },
                |m: &mut CombatEvent| { &mut m.friend_or_foe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CombatResult>>(
                "result",
                |m: &CombatEvent| { &m.result },
                |m: &mut CombatEvent| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CombatActivation>>(
                "activation",
                |m: &CombatEvent| { &m.activation },
                |m: &mut CombatEvent| { &mut m.activation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BuffRemoveType>>(
                "buffremove",
                |m: &CombatEvent| { &m.buffremove },
                |m: &mut CombatEvent| { &mut m.buffremove },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "src_hp_over_90",
                |m: &CombatEvent| { &m.src_hp_over_90 },
                |m: &mut CombatEvent| { &mut m.src_hp_over_90 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dst_hp_over_50",
                |m: &CombatEvent| { &m.dst_hp_over_50 },
                |m: &mut CombatEvent| { &mut m.dst_hp_over_50 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "src_is_moving",
                |m: &CombatEvent| { &m.src_is_moving },
                |m: &mut CombatEvent| { &mut m.src_is_moving },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StateChange>>(
                "statechange",
                |m: &CombatEvent| { &m.statechange },
                |m: &mut CombatEvent| { &mut m.statechange },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_flanking",
                |m: &CombatEvent| { &m.is_flanking },
                |m: &mut CombatEvent| { &mut m.is_flanking },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "buff_added_active",
                |m: &CombatEvent| { &m.buff_added_active },
                |m: &mut CombatEvent| { &mut m.buff_added_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_offcycle",
                |m: &CombatEvent| { &m.is_offcycle },
                |m: &mut CombatEvent| { &mut m.is_offcycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad61",
                |m: &CombatEvent| { &m.pad61 },
                |m: &mut CombatEvent| { &mut m.pad61 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad62",
                |m: &CombatEvent| { &m.pad62 },
                |m: &mut CombatEvent| { &mut m.pad62 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad63",
                |m: &CombatEvent| { &m.pad63 },
                |m: &mut CombatEvent| { &mut m.pad63 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad64",
                |m: &CombatEvent| { &m.pad64 },
                |m: &mut CombatEvent| { &mut m.pad64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "target_downed",
                |m: &CombatEvent| { &m.target_downed },
                |m: &mut CombatEvent| { &mut m.target_downed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "buff_stacks_removed",
                |m: &CombatEvent| { &m.buff_stacks_removed },
                |m: &mut CombatEvent| { &mut m.buff_stacks_removed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "buff_duration",
                |m: &CombatEvent| { &m.buff_duration },
                |m: &mut CombatEvent| { &mut m.buff_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tag_id",
                |m: &CombatEvent| { &m.tag_id },
                |m: &mut CombatEvent| { &mut m.tag_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "buff_stackid",
                |m: &CombatEvent| { &m.buff_stackid },
                |m: &mut CombatEvent| { &mut m.buff_stackid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_team_id",
                |m: &CombatEvent| { &m.new_team_id },
                |m: &mut CombatEvent| { &mut m.new_team_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reward_id",
                |m: &CombatEvent| { &m.reward_id },
                |m: &mut CombatEvent| { &mut m.reward_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reward_type",
                |m: &CombatEvent| { &m.reward_type },
                |m: &mut CombatEvent| { &mut m.reward_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WeaponSet>>(
                "weapon_set",
                |m: &CombatEvent| { &m.weapon_set },
                |m: &mut CombatEvent| { &mut m.weapon_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_in_animation",
                |m: &CombatEvent| { &m.time_in_animation },
                |m: &mut CombatEvent| { &mut m.time_in_animation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_in_animation_scaled",
                |m: &CombatEvent| { &m.time_in_animation_scaled },
                |m: &mut CombatEvent| { &mut m.time_in_animation_scaled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EventType>>(
                "EventType",
                |m: &CombatEvent| { &m.EventType },
                |m: &mut CombatEvent| { &mut m.EventType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BuffDamageResult>>(
                "buff_damage_result",
                |m: &CombatEvent| { &m.buff_damage_result },
                |m: &mut CombatEvent| { &mut m.buff_damage_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BuffType>>(
                "buff_type",
                |m: &CombatEvent| { &m.buff_type },
                |m: &mut CombatEvent| { &mut m.buff_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CombatEvent>(
                "CombatEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CombatEvent {
        static instance: ::protobuf::rt::LazyV2<CombatEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CombatEvent::new)
    }
}

impl ::protobuf::Clear for CombatEvent {
    fn clear(&mut self) {
        self.time = 0;
        self.damage = 0;
        self.shield_damage = 0;
        self.skillid = 0;
        self.src_instid = 0;
        self.dst_instid = 0;
        self.src_master_instid = 0;
        self.friend_or_foe = Affinity::AF_Unparsed;
        self.result = CombatResult::Normal;
        self.activation = CombatActivation::CA_NONE;
        self.buffremove = BuffRemoveType::BR_None;
        self.src_hp_over_90 = false;
        self.dst_hp_over_50 = false;
        self.src_is_moving = false;
        self.statechange = StateChange::NONE;
        self.is_flanking = false;
        self.buff_added_active = false;
        self.is_offcycle = 0;
        self.pad61 = 0;
        self.pad62 = 0;
        self.pad63 = 0;
        self.pad64 = 0;
        self.target_downed = false;
        self.buff_stacks_removed = 0;
        self.buff_duration = 0;
        self.tag_id = 0;
        self.buff_stackid = 0;
        self.new_team_id = 0;
        self.reward_id = 0;
        self.reward_type = 0;
        self.weapon_set = WeaponSet::WS_Unparsed;
        self.time_in_animation = 0;
        self.time_in_animation_scaled = 0;
        self.EventType = EventType::None;
        self.buff_damage_result = BuffDamageResult::BD_Unparsed;
        self.buff_type = BuffType::BT_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CombatEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CombatMessage {
    // message fields
    pub combat_type: CombatType,
    pub combat_event: ::protobuf::SingularPtrField<CombatEvent>,
    pub src_actor: ::protobuf::SingularPtrField<Actor>,
    pub dst_actor: ::protobuf::SingularPtrField<Actor>,
    pub skillname: ::std::string::String,
    pub id: u64,
    pub revision: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CombatMessage {
    fn default() -> &'a CombatMessage {
        <CombatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CombatMessage {
    pub fn new() -> CombatMessage {
        ::std::default::Default::default()
    }

    // .CombatType combat_type = 1;


    pub fn get_combat_type(&self) -> CombatType {
        self.combat_type
    }
    pub fn clear_combat_type(&mut self) {
        self.combat_type = CombatType::CT_UnParsed;
    }

    // Param is passed by value, moved
    pub fn set_combat_type(&mut self, v: CombatType) {
        self.combat_type = v;
    }

    // .CombatEvent combat_event = 2;


    pub fn get_combat_event(&self) -> &CombatEvent {
        self.combat_event.as_ref().unwrap_or_else(|| <CombatEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_combat_event(&mut self) {
        self.combat_event.clear();
    }

    pub fn has_combat_event(&self) -> bool {
        self.combat_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combat_event(&mut self, v: CombatEvent) {
        self.combat_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_combat_event(&mut self) -> &mut CombatEvent {
        if self.combat_event.is_none() {
            self.combat_event.set_default();
        }
        self.combat_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_combat_event(&mut self) -> CombatEvent {
        self.combat_event.take().unwrap_or_else(|| CombatEvent::new())
    }

    // .Actor src_actor = 3;


    pub fn get_src_actor(&self) -> &Actor {
        self.src_actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_src_actor(&mut self) {
        self.src_actor.clear();
    }

    pub fn has_src_actor(&self) -> bool {
        self.src_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_actor(&mut self, v: Actor) {
        self.src_actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_actor(&mut self) -> &mut Actor {
        if self.src_actor.is_none() {
            self.src_actor.set_default();
        }
        self.src_actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_actor(&mut self) -> Actor {
        self.src_actor.take().unwrap_or_else(|| Actor::new())
    }

    // .Actor dst_actor = 4;


    pub fn get_dst_actor(&self) -> &Actor {
        self.dst_actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dst_actor(&mut self) {
        self.dst_actor.clear();
    }

    pub fn has_dst_actor(&self) -> bool {
        self.dst_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_actor(&mut self, v: Actor) {
        self.dst_actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_actor(&mut self) -> &mut Actor {
        if self.dst_actor.is_none() {
            self.dst_actor.set_default();
        }
        self.dst_actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_actor(&mut self) -> Actor {
        self.dst_actor.take().unwrap_or_else(|| Actor::new())
    }

    // string skillname = 5;


    pub fn get_skillname(&self) -> &str {
        &self.skillname
    }
    pub fn clear_skillname(&mut self) {
        self.skillname.clear();
    }

    // Param is passed by value, moved
    pub fn set_skillname(&mut self, v: ::std::string::String) {
        self.skillname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_skillname(&mut self) -> &mut ::std::string::String {
        &mut self.skillname
    }

    // Take field
    pub fn take_skillname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.skillname, ::std::string::String::new())
    }

    // uint64 id = 6;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint64 revision = 7;


    pub fn get_revision(&self) -> u64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u64) {
        self.revision = v;
    }
}

impl ::protobuf::Message for CombatMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.combat_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.src_actor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dst_actor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.combat_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.combat_event)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_actor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst_actor)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.skillname)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.combat_type != CombatType::CT_UnParsed {
            my_size += ::protobuf::rt::enum_size(1, self.combat_type);
        }
        if let Some(ref v) = self.combat_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.src_actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst_actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.skillname.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.skillname);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(7, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.combat_type != CombatType::CT_UnParsed {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.combat_type))?;
        }
        if let Some(ref v) = self.combat_event.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.src_actor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst_actor.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.skillname.is_empty() {
            os.write_string(5, &self.skillname)?;
        }
        if self.id != 0 {
            os.write_uint64(6, self.id)?;
        }
        if self.revision != 0 {
            os.write_uint64(7, self.revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CombatMessage {
        CombatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CombatType>>(
                "combat_type",
                |m: &CombatMessage| { &m.combat_type },
                |m: &mut CombatMessage| { &mut m.combat_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CombatEvent>>(
                "combat_event",
                |m: &CombatMessage| { &m.combat_event },
                |m: &mut CombatMessage| { &mut m.combat_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "src_actor",
                |m: &CombatMessage| { &m.src_actor },
                |m: &mut CombatMessage| { &mut m.src_actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "dst_actor",
                |m: &CombatMessage| { &m.dst_actor },
                |m: &mut CombatMessage| { &mut m.dst_actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "skillname",
                |m: &CombatMessage| { &m.skillname },
                |m: &mut CombatMessage| { &mut m.skillname },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CombatMessage| { &m.id },
                |m: &mut CombatMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "revision",
                |m: &CombatMessage| { &m.revision },
                |m: &mut CombatMessage| { &mut m.revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CombatMessage>(
                "CombatMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CombatMessage {
        static instance: ::protobuf::rt::LazyV2<CombatMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CombatMessage::new)
    }
}

impl ::protobuf::Clear for CombatMessage {
    fn clear(&mut self) {
        self.combat_type = CombatType::CT_UnParsed;
        self.combat_event.clear();
        self.src_actor.clear();
        self.dst_actor.clear();
        self.skillname.clear();
        self.id = 0;
        self.revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CombatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub imgui_event: ::protobuf::SingularPtrField<ImGuiEvent>,
    pub combat_message: ::protobuf::SingularPtrField<CombatMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // .ImGuiEvent imgui_event = 1;


    pub fn get_imgui_event(&self) -> &ImGuiEvent {
        self.imgui_event.as_ref().unwrap_or_else(|| <ImGuiEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_imgui_event(&mut self) {
        self.imgui_event.clear();
    }

    pub fn has_imgui_event(&self) -> bool {
        self.imgui_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imgui_event(&mut self, v: ImGuiEvent) {
        self.imgui_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imgui_event(&mut self) -> &mut ImGuiEvent {
        if self.imgui_event.is_none() {
            self.imgui_event.set_default();
        }
        self.imgui_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_imgui_event(&mut self) -> ImGuiEvent {
        self.imgui_event.take().unwrap_or_else(|| ImGuiEvent::new())
    }

    // .CombatMessage combat_message = 2;


    pub fn get_combat_message(&self) -> &CombatMessage {
        self.combat_message.as_ref().unwrap_or_else(|| <CombatMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_combat_message(&mut self) {
        self.combat_message.clear();
    }

    pub fn has_combat_message(&self) -> bool {
        self.combat_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combat_message(&mut self, v: CombatMessage) {
        self.combat_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_combat_message(&mut self) -> &mut CombatMessage {
        if self.combat_message.is_none() {
            self.combat_message.set_default();
        }
        self.combat_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_combat_message(&mut self) -> CombatMessage {
        self.combat_message.take().unwrap_or_else(|| CombatMessage::new())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.imgui_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.combat_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.imgui_event)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.combat_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.imgui_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.combat_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.imgui_event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.combat_message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImGuiEvent>>(
                "imgui_event",
                |m: &Event| { &m.imgui_event },
                |m: &mut Event| { &mut m.imgui_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CombatMessage>>(
                "combat_message",
                |m: &Event| { &m.combat_message },
                |m: &mut Event| { &mut m.combat_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                "Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.imgui_event.clear();
        self.combat_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UiState {
    Default = 0,
    CharacterSelectionOrLoading = 1,
}

impl ::protobuf::ProtobufEnum for UiState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UiState> {
        match value {
            0 => ::std::option::Option::Some(UiState::Default),
            1 => ::std::option::Option::Some(UiState::CharacterSelectionOrLoading),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UiState] = &[
            UiState::Default,
            UiState::CharacterSelectionOrLoading,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UiState>("UiState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UiState {
}

impl ::std::default::Default for UiState {
    fn default() -> Self {
        UiState::Default
    }
}

impl ::protobuf::reflect::ProtobufValue for UiState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CombatType {
    CT_UnParsed = 0,
    Area = 1,
    Local = 2,
}

impl ::protobuf::ProtobufEnum for CombatType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CombatType> {
        match value {
            0 => ::std::option::Option::Some(CombatType::CT_UnParsed),
            1 => ::std::option::Option::Some(CombatType::Area),
            2 => ::std::option::Option::Some(CombatType::Local),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CombatType] = &[
            CombatType::CT_UnParsed,
            CombatType::Area,
            CombatType::Local,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CombatType>("CombatType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CombatType {
}

impl ::std::default::Default for CombatType {
    fn default() -> Self {
        CombatType::CT_UnParsed
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuffType {
    BT_NONE = 0,
    POWER = 1,
    PRECISION = 2,
    TOUGHNESS = 3,
    VITALITY = 4,
    FEROCITY = 5,
    HEALING = 6,
    CONDITION = 7,
    CONCENTRATION = 8,
    EXPERTISE = 9,
    CUST_ARMOR = 10,
    CUST_AGONY = 11,
    CUST_STATINC = 12,
    CUST_PHYSINC = 13,
    CUST_CONDINC = 14,
    CUST_PHYSREC = 15,
    CUST_CONDREC = 16,
    CUST_ATTACKSPEED = 17,
    CUST_SIPHONINC = 18,
    CUST_SIPHONREC = 19,
    BT_UNPARSED = 20,
    BT_UNKNOWN = 65535,
}

impl ::protobuf::ProtobufEnum for BuffType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuffType> {
        match value {
            0 => ::std::option::Option::Some(BuffType::BT_NONE),
            1 => ::std::option::Option::Some(BuffType::POWER),
            2 => ::std::option::Option::Some(BuffType::PRECISION),
            3 => ::std::option::Option::Some(BuffType::TOUGHNESS),
            4 => ::std::option::Option::Some(BuffType::VITALITY),
            5 => ::std::option::Option::Some(BuffType::FEROCITY),
            6 => ::std::option::Option::Some(BuffType::HEALING),
            7 => ::std::option::Option::Some(BuffType::CONDITION),
            8 => ::std::option::Option::Some(BuffType::CONCENTRATION),
            9 => ::std::option::Option::Some(BuffType::EXPERTISE),
            10 => ::std::option::Option::Some(BuffType::CUST_ARMOR),
            11 => ::std::option::Option::Some(BuffType::CUST_AGONY),
            12 => ::std::option::Option::Some(BuffType::CUST_STATINC),
            13 => ::std::option::Option::Some(BuffType::CUST_PHYSINC),
            14 => ::std::option::Option::Some(BuffType::CUST_CONDINC),
            15 => ::std::option::Option::Some(BuffType::CUST_PHYSREC),
            16 => ::std::option::Option::Some(BuffType::CUST_CONDREC),
            17 => ::std::option::Option::Some(BuffType::CUST_ATTACKSPEED),
            18 => ::std::option::Option::Some(BuffType::CUST_SIPHONINC),
            19 => ::std::option::Option::Some(BuffType::CUST_SIPHONREC),
            20 => ::std::option::Option::Some(BuffType::BT_UNPARSED),
            65535 => ::std::option::Option::Some(BuffType::BT_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuffType] = &[
            BuffType::BT_NONE,
            BuffType::POWER,
            BuffType::PRECISION,
            BuffType::TOUGHNESS,
            BuffType::VITALITY,
            BuffType::FEROCITY,
            BuffType::HEALING,
            BuffType::CONDITION,
            BuffType::CONCENTRATION,
            BuffType::EXPERTISE,
            BuffType::CUST_ARMOR,
            BuffType::CUST_AGONY,
            BuffType::CUST_STATINC,
            BuffType::CUST_PHYSINC,
            BuffType::CUST_CONDINC,
            BuffType::CUST_PHYSREC,
            BuffType::CUST_CONDREC,
            BuffType::CUST_ATTACKSPEED,
            BuffType::CUST_SIPHONINC,
            BuffType::CUST_SIPHONREC,
            BuffType::BT_UNPARSED,
            BuffType::BT_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BuffType>("BuffType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BuffType {
}

impl ::std::default::Default for BuffType {
    fn default() -> Self {
        BuffType::BT_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for BuffType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Affinity {
    AF_Unparsed = 0,
    Friend = 1,
    Foe = 2,
    Unknown = 3,
}

impl ::protobuf::ProtobufEnum for Affinity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Affinity> {
        match value {
            0 => ::std::option::Option::Some(Affinity::AF_Unparsed),
            1 => ::std::option::Option::Some(Affinity::Friend),
            2 => ::std::option::Option::Some(Affinity::Foe),
            3 => ::std::option::Option::Some(Affinity::Unknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Affinity] = &[
            Affinity::AF_Unparsed,
            Affinity::Friend,
            Affinity::Foe,
            Affinity::Unknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Affinity>("Affinity", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Affinity {
}

impl ::std::default::Default for Affinity {
    fn default() -> Self {
        Affinity::AF_Unparsed
    }
}

impl ::protobuf::reflect::ProtobufValue for Affinity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuffDamageResult {
    BD_Unparsed = 0,
    BD_Normal = 1,
    InvulnerableFromBuff = 2,
    InvulnerableFromSkill1 = 3,
    InvulnerableFromSkill2 = 4,
    InvulnerableFromSkill3 = 5,
}

impl ::protobuf::ProtobufEnum for BuffDamageResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuffDamageResult> {
        match value {
            0 => ::std::option::Option::Some(BuffDamageResult::BD_Unparsed),
            1 => ::std::option::Option::Some(BuffDamageResult::BD_Normal),
            2 => ::std::option::Option::Some(BuffDamageResult::InvulnerableFromBuff),
            3 => ::std::option::Option::Some(BuffDamageResult::InvulnerableFromSkill1),
            4 => ::std::option::Option::Some(BuffDamageResult::InvulnerableFromSkill2),
            5 => ::std::option::Option::Some(BuffDamageResult::InvulnerableFromSkill3),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuffDamageResult] = &[
            BuffDamageResult::BD_Unparsed,
            BuffDamageResult::BD_Normal,
            BuffDamageResult::InvulnerableFromBuff,
            BuffDamageResult::InvulnerableFromSkill1,
            BuffDamageResult::InvulnerableFromSkill2,
            BuffDamageResult::InvulnerableFromSkill3,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BuffDamageResult>("BuffDamageResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BuffDamageResult {
}

impl ::std::default::Default for BuffDamageResult {
    fn default() -> Self {
        BuffDamageResult::BD_Unparsed
    }
}

impl ::protobuf::reflect::ProtobufValue for BuffDamageResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CombatResult {
    Normal = 0,
    Critical = 1,
    Glance = 2,
    Block = 3,
    Evade = 4,
    Interrupt = 5,
    Absorb = 6,
    Blind = 7,
    KillingBlow = 8,
    Downed = 9,
    Breakbar = 10,
    OnActivation = 11,
    CR_Unknown = 12,
    CR_Unparsed = 13,
}

impl ::protobuf::ProtobufEnum for CombatResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CombatResult> {
        match value {
            0 => ::std::option::Option::Some(CombatResult::Normal),
            1 => ::std::option::Option::Some(CombatResult::Critical),
            2 => ::std::option::Option::Some(CombatResult::Glance),
            3 => ::std::option::Option::Some(CombatResult::Block),
            4 => ::std::option::Option::Some(CombatResult::Evade),
            5 => ::std::option::Option::Some(CombatResult::Interrupt),
            6 => ::std::option::Option::Some(CombatResult::Absorb),
            7 => ::std::option::Option::Some(CombatResult::Blind),
            8 => ::std::option::Option::Some(CombatResult::KillingBlow),
            9 => ::std::option::Option::Some(CombatResult::Downed),
            10 => ::std::option::Option::Some(CombatResult::Breakbar),
            11 => ::std::option::Option::Some(CombatResult::OnActivation),
            12 => ::std::option::Option::Some(CombatResult::CR_Unknown),
            13 => ::std::option::Option::Some(CombatResult::CR_Unparsed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CombatResult] = &[
            CombatResult::Normal,
            CombatResult::Critical,
            CombatResult::Glance,
            CombatResult::Block,
            CombatResult::Evade,
            CombatResult::Interrupt,
            CombatResult::Absorb,
            CombatResult::Blind,
            CombatResult::KillingBlow,
            CombatResult::Downed,
            CombatResult::Breakbar,
            CombatResult::OnActivation,
            CombatResult::CR_Unknown,
            CombatResult::CR_Unparsed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CombatResult>("CombatResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CombatResult {
}

impl ::std::default::Default for CombatResult {
    fn default() -> Self {
        CombatResult::Normal
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventType {
    None = 0,
    DirectDamage = 7,
    BuffApplied = 1,
    BuffRemoved = 2,
    StateChanged = 3,
    ET_Unparsed = 4,
    Activation = 5,
    BuffDamage = 6,
}

impl ::protobuf::ProtobufEnum for EventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventType> {
        match value {
            0 => ::std::option::Option::Some(EventType::None),
            7 => ::std::option::Option::Some(EventType::DirectDamage),
            1 => ::std::option::Option::Some(EventType::BuffApplied),
            2 => ::std::option::Option::Some(EventType::BuffRemoved),
            3 => ::std::option::Option::Some(EventType::StateChanged),
            4 => ::std::option::Option::Some(EventType::ET_Unparsed),
            5 => ::std::option::Option::Some(EventType::Activation),
            6 => ::std::option::Option::Some(EventType::BuffDamage),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventType] = &[
            EventType::None,
            EventType::DirectDamage,
            EventType::BuffApplied,
            EventType::BuffRemoved,
            EventType::StateChanged,
            EventType::ET_Unparsed,
            EventType::Activation,
            EventType::BuffDamage,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EventType>("EventType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EventType {
}

impl ::std::default::Default for EventType {
    fn default() -> Self {
        EventType::None
    }
}

impl ::protobuf::reflect::ProtobufValue for EventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StateChange {
    NONE = 0,
    ENTERCOMBAT = 1,
    EXITCOMBAT = 2,
    CHANGEUP = 3,
    CHANGEDEAD = 4,
    CHANGEDOWN = 5,
    LOGSTART = 9,
    LOGEND = 10,
    WEAPSWAP = 11,
    REWARD = 17,
    BUFFINITIAL = 18,
    TEAMCHANGE = 19,
    STACKACTIVE = 24,
    STACKRESET = 25,
    GUILD = 26,
    TAG = 33,
    STATRESET = 35,
    EXTENSION = 36,
    APIDELAYED = 37,
    INSTANCESTART = 38,
    UNKNOWN = 39,
    SC_UNPARSED = 40,
}

impl ::protobuf::ProtobufEnum for StateChange {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StateChange> {
        match value {
            0 => ::std::option::Option::Some(StateChange::NONE),
            1 => ::std::option::Option::Some(StateChange::ENTERCOMBAT),
            2 => ::std::option::Option::Some(StateChange::EXITCOMBAT),
            3 => ::std::option::Option::Some(StateChange::CHANGEUP),
            4 => ::std::option::Option::Some(StateChange::CHANGEDEAD),
            5 => ::std::option::Option::Some(StateChange::CHANGEDOWN),
            9 => ::std::option::Option::Some(StateChange::LOGSTART),
            10 => ::std::option::Option::Some(StateChange::LOGEND),
            11 => ::std::option::Option::Some(StateChange::WEAPSWAP),
            17 => ::std::option::Option::Some(StateChange::REWARD),
            18 => ::std::option::Option::Some(StateChange::BUFFINITIAL),
            19 => ::std::option::Option::Some(StateChange::TEAMCHANGE),
            24 => ::std::option::Option::Some(StateChange::STACKACTIVE),
            25 => ::std::option::Option::Some(StateChange::STACKRESET),
            26 => ::std::option::Option::Some(StateChange::GUILD),
            33 => ::std::option::Option::Some(StateChange::TAG),
            35 => ::std::option::Option::Some(StateChange::STATRESET),
            36 => ::std::option::Option::Some(StateChange::EXTENSION),
            37 => ::std::option::Option::Some(StateChange::APIDELAYED),
            38 => ::std::option::Option::Some(StateChange::INSTANCESTART),
            39 => ::std::option::Option::Some(StateChange::UNKNOWN),
            40 => ::std::option::Option::Some(StateChange::SC_UNPARSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StateChange] = &[
            StateChange::NONE,
            StateChange::ENTERCOMBAT,
            StateChange::EXITCOMBAT,
            StateChange::CHANGEUP,
            StateChange::CHANGEDEAD,
            StateChange::CHANGEDOWN,
            StateChange::LOGSTART,
            StateChange::LOGEND,
            StateChange::WEAPSWAP,
            StateChange::REWARD,
            StateChange::BUFFINITIAL,
            StateChange::TEAMCHANGE,
            StateChange::STACKACTIVE,
            StateChange::STACKRESET,
            StateChange::GUILD,
            StateChange::TAG,
            StateChange::STATRESET,
            StateChange::EXTENSION,
            StateChange::APIDELAYED,
            StateChange::INSTANCESTART,
            StateChange::UNKNOWN,
            StateChange::SC_UNPARSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StateChange>("StateChange", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StateChange {
}

impl ::std::default::Default for StateChange {
    fn default() -> Self {
        StateChange::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for StateChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CombatActivation {
    CA_NONE = 0,
    START = 1,
    QUICKNESS_UNUSED = 2,
    CANCEL_FIRE = 3,
    CANCEL_CANCEL = 4,
    RESET = 5,
    CA_UNKNOWN = 6,
    CA_UNPARSED = 7,
}

impl ::protobuf::ProtobufEnum for CombatActivation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CombatActivation> {
        match value {
            0 => ::std::option::Option::Some(CombatActivation::CA_NONE),
            1 => ::std::option::Option::Some(CombatActivation::START),
            2 => ::std::option::Option::Some(CombatActivation::QUICKNESS_UNUSED),
            3 => ::std::option::Option::Some(CombatActivation::CANCEL_FIRE),
            4 => ::std::option::Option::Some(CombatActivation::CANCEL_CANCEL),
            5 => ::std::option::Option::Some(CombatActivation::RESET),
            6 => ::std::option::Option::Some(CombatActivation::CA_UNKNOWN),
            7 => ::std::option::Option::Some(CombatActivation::CA_UNPARSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CombatActivation] = &[
            CombatActivation::CA_NONE,
            CombatActivation::START,
            CombatActivation::QUICKNESS_UNUSED,
            CombatActivation::CANCEL_FIRE,
            CombatActivation::CANCEL_CANCEL,
            CombatActivation::RESET,
            CombatActivation::CA_UNKNOWN,
            CombatActivation::CA_UNPARSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CombatActivation>("CombatActivation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CombatActivation {
}

impl ::std::default::Default for CombatActivation {
    fn default() -> Self {
        CombatActivation::CA_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatActivation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuffRemoveType {
    BR_None = 0,
    All = 1,
    Single = 2,
    Manual = 3,
    BR_Unparsed = 4,
}

impl ::protobuf::ProtobufEnum for BuffRemoveType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuffRemoveType> {
        match value {
            0 => ::std::option::Option::Some(BuffRemoveType::BR_None),
            1 => ::std::option::Option::Some(BuffRemoveType::All),
            2 => ::std::option::Option::Some(BuffRemoveType::Single),
            3 => ::std::option::Option::Some(BuffRemoveType::Manual),
            4 => ::std::option::Option::Some(BuffRemoveType::BR_Unparsed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuffRemoveType] = &[
            BuffRemoveType::BR_None,
            BuffRemoveType::All,
            BuffRemoveType::Single,
            BuffRemoveType::Manual,
            BuffRemoveType::BR_Unparsed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BuffRemoveType>("BuffRemoveType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BuffRemoveType {
}

impl ::std::default::Default for BuffRemoveType {
    fn default() -> Self {
        BuffRemoveType::BR_None
    }
}

impl ::protobuf::reflect::ProtobufValue for BuffRemoveType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WeaponSet {
    WS_Unparsed = 0,
    WaterSetOne = 1,
    WaterSetTwo = 2,
    LandSetOne = 5,
    LandSetTwo = 6,
}

impl ::protobuf::ProtobufEnum for WeaponSet {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WeaponSet> {
        match value {
            0 => ::std::option::Option::Some(WeaponSet::WS_Unparsed),
            1 => ::std::option::Option::Some(WeaponSet::WaterSetOne),
            2 => ::std::option::Option::Some(WeaponSet::WaterSetTwo),
            5 => ::std::option::Option::Some(WeaponSet::LandSetOne),
            6 => ::std::option::Option::Some(WeaponSet::LandSetTwo),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WeaponSet] = &[
            WeaponSet::WS_Unparsed,
            WeaponSet::WaterSetOne,
            WeaponSet::WaterSetTwo,
            WeaponSet::LandSetOne,
            WeaponSet::LandSetTwo,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WeaponSet>("WeaponSet", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WeaponSet {
}

impl ::std::default::Default for WeaponSet {
    fn default() -> Self {
        WeaponSet::WS_Unparsed
    }
}

impl ::protobuf::reflect::ProtobufValue for WeaponSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0feventdata.proto\"4\n\nImGuiEvent\x12$\n\x07UiState\x18\x01\x20\x01\
    (\x0e2\x08.UiStateR\x07UiStateB\0:\0\"\xa8\x01\n\x05Actor\x12\x14\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04nameB\0\x12\x10\n\x02id\x18\x02\x20\x01(\rR\
    \x02idB\0\x12\x20\n\nProfession\x18\x03\x20\x01(\rR\nProfessionB\0\x12\
    \x1e\n\tEliteSpec\x18\x04\x20\x01(\rR\tEliteSpecB\0\x12\x1d\n\tis_player\
    \x18\x05\x20\x01(\x08R\x08isPlayerB\0\x12\x14\n\x04team\x18\x06\x20\x01(\
    \rR\x04teamB\0:\0\"\xff\n\n\x0bCombatEvent\x12\x14\n\x04time\x18\x01\x20\
    \x01(\x04R\x04timeB\0\x12\x18\n\x06damage\x18\x04\x20\x01(\x05R\x06damag\
    eB\0\x12%\n\rshield_damage\x18\x06\x20\x01(\rR\x0cshieldDamageB\0\x12\
    \x1a\n\x07skillid\x18\x07\x20\x01(\rR\x07skillidB\0\x12\x1f\n\nsrc_insti\
    d\x18\x08\x20\x01(\rR\tsrcInstidB\0\x12\x1f\n\ndst_instid\x18\t\x20\x01(\
    \rR\tdstInstidB\0\x12,\n\x11src_master_instid\x18\n\x20\x01(\rR\x0fsrcMa\
    sterInstidB\0\x12/\n\rfriend_or_foe\x18\x0b\x20\x01(\x0e2\t.AffinityR\
    \x0bfriendOrFoeB\0\x12'\n\x06result\x18\r\x20\x01(\x0e2\r.CombatResultR\
    \x06resultB\0\x123\n\nactivation\x18\x0e\x20\x01(\x0e2\x11.CombatActivat\
    ionR\nactivationB\0\x121\n\nbuffremove\x18\x0f\x20\x01(\x0e2\x0f.BuffRem\
    oveTypeR\nbuffremoveB\0\x12%\n\x0esrc_hp_over_90\x18\x10\x20\x01(\x08R\
    \x0bsrcHpOver90B\0\x12%\n\x0edst_hp_over_50\x18\x11\x20\x01(\x08R\x0bdst\
    HpOver50B\0\x12$\n\rsrc_is_moving\x18\x12\x20\x01(\x08R\x0bsrcIsMovingB\
    \0\x120\n\x0bstatechange\x18\x13\x20\x01(\x0e2\x0c.StateChangeR\x0bstate\
    changeB\0\x12!\n\x0bis_flanking\x18\x14\x20\x01(\x08R\nisFlankingB\0\x12\
    ,\n\x11buff_added_active\x18\x15\x20\x01(\x08R\x0fbuffAddedActiveB\0\x12\
    !\n\x0bis_offcycle\x18\x16\x20\x01(\rR\nisOffcycleB\0\x12\x16\n\x05pad61\
    \x18\x17\x20\x01(\rR\x05pad61B\0\x12\x16\n\x05pad62\x18\x18\x20\x01(\rR\
    \x05pad62B\0\x12\x16\n\x05pad63\x18\x19\x20\x01(\rR\x05pad63B\0\x12\x16\
    \n\x05pad64\x18\x1a\x20\x01(\rR\x05pad64B\0\x12%\n\rtarget_downed\x18\
    \x1b\x20\x01(\x08R\x0ctargetDownedB\0\x120\n\x13buff_stacks_removed\x18\
    \x1c\x20\x01(\x05R\x11buffStacksRemovedB\0\x12%\n\rbuff_duration\x18\x1d\
    \x20\x01(\x05R\x0cbuffDurationB\0\x12\x17\n\x06tag_id\x18\x1e\x20\x01(\r\
    R\x05tagIdB\0\x12#\n\x0cbuff_stackid\x18\x1f\x20\x01(\rR\x0bbuffStackidB\
    \0\x12\x20\n\x0bnew_team_id\x18\x20\x20\x01(\rR\tnewTeamIdB\0\x12\x1d\n\
    \treward_id\x18!\x20\x01(\rR\x08rewardIdB\0\x12!\n\x0breward_type\x18\"\
    \x20\x01(\rR\nrewardTypeB\0\x12+\n\nweapon_set\x18#\x20\x01(\x0e2\n.Weap\
    onSetR\tweaponSetB\0\x12,\n\x11time_in_animation\x18$\x20\x01(\rR\x0ftim\
    eInAnimationB\0\x129\n\x18time_in_animation_scaled\x18%\x20\x01(\rR\x15t\
    imeInAnimationScaledB\0\x12*\n\tEventType\x18&\x20\x01(\x0e2\n.EventType\
    R\tEventTypeB\0\x12A\n\x12buff_damage_result\x18'\x20\x01(\x0e2\x11.Buff\
    DamageResultR\x10buffDamageResultB\0\x12(\n\tbuff_type\x18(\x20\x01(\x0e\
    2\t.BuffTypeR\x08buffTypeB\0:\0\"\x92\x02\n\rCombatMessage\x12.\n\x0bcom\
    bat_type\x18\x01\x20\x01(\x0e2\x0b.CombatTypeR\ncombatTypeB\0\x121\n\x0c\
    combat_event\x18\x02\x20\x01(\x0b2\x0c.CombatEventR\x0bcombatEventB\0\
    \x12%\n\tsrc_actor\x18\x03\x20\x01(\x0b2\x06.ActorR\x08srcActorB\0\x12%\
    \n\tdst_actor\x18\x04\x20\x01(\x0b2\x06.ActorR\x08dstActorB\0\x12\x1e\n\
    \tskillname\x18\x05\x20\x01(\tR\tskillnameB\0\x12\x10\n\x02id\x18\x06\
    \x20\x01(\x04R\x02idB\0\x12\x1c\n\x08revision\x18\x07\x20\x01(\x04R\x08r\
    evisionB\0:\0\"r\n\x05Event\x12.\n\x0bimgui_event\x18\x01\x20\x01(\x0b2\
    \x0b.ImGuiEventR\nimguiEventB\0\x127\n\x0ecombat_message\x18\x02\x20\x01\
    (\x0b2\x0e.CombatMessageR\rcombatMessageB\0:\0*9\n\x07UiState\x12\x0b\n\
    \x07Default\x10\0\x12\x1f\n\x1bCharacterSelectionOrLoading\x10\x01\x1a\0\
    *4\n\nCombatType\x12\x0f\n\x0bCT_UnParsed\x10\0\x12\x08\n\x04Area\x10\
    \x01\x12\t\n\x05Local\x10\x02\x1a\0*\xf7\x02\n\x08BuffType\x12\x0b\n\x07\
    BT_NONE\x10\0\x12\t\n\x05POWER\x10\x01\x12\r\n\tPRECISION\x10\x02\x12\r\
    \n\tTOUGHNESS\x10\x03\x12\x0c\n\x08VITALITY\x10\x04\x12\x0c\n\x08FEROCIT\
    Y\x10\x05\x12\x0b\n\x07HEALING\x10\x06\x12\r\n\tCONDITION\x10\x07\x12\
    \x11\n\rCONCENTRATION\x10\x08\x12\r\n\tEXPERTISE\x10\t\x12\x0e\n\nCUST_A\
    RMOR\x10\n\x12\x0e\n\nCUST_AGONY\x10\x0b\x12\x10\n\x0cCUST_STATINC\x10\
    \x0c\x12\x10\n\x0cCUST_PHYSINC\x10\r\x12\x10\n\x0cCUST_CONDINC\x10\x0e\
    \x12\x10\n\x0cCUST_PHYSREC\x10\x0f\x12\x10\n\x0cCUST_CONDREC\x10\x10\x12\
    \x14\n\x10CUST_ATTACKSPEED\x10\x11\x12\x12\n\x0eCUST_SIPHONINC\x10\x12\
    \x12\x12\n\x0eCUST_SIPHONREC\x10\x13\x12\x0f\n\x0bBT_UNPARSED\x10\x14\
    \x12\x10\n\nBT_UNKNOWN\x10\xff\xff\x03\x1a\0*?\n\x08Affinity\x12\x0f\n\
    \x0bAF_Unparsed\x10\0\x12\n\n\x06Friend\x10\x01\x12\x07\n\x03Foe\x10\x02\
    \x12\x0b\n\x07Unknown\x10\x03\x1a\0*\xa2\x01\n\x10BuffDamageResult\x12\
    \x0f\n\x0bBD_Unparsed\x10\0\x12\r\n\tBD_Normal\x10\x01\x12\x18\n\x14Invu\
    lnerableFromBuff\x10\x02\x12\x1a\n\x16InvulnerableFromSkill1\x10\x03\x12\
    \x1a\n\x16InvulnerableFromSkill2\x10\x04\x12\x1a\n\x16InvulnerableFromSk\
    ill3\x10\x05\x1a\0*\xd0\x01\n\x0cCombatResult\x12\n\n\x06Normal\x10\0\
    \x12\x0c\n\x08Critical\x10\x01\x12\n\n\x06Glance\x10\x02\x12\t\n\x05Bloc\
    k\x10\x03\x12\t\n\x05Evade\x10\x04\x12\r\n\tInterrupt\x10\x05\x12\n\n\
    \x06Absorb\x10\x06\x12\t\n\x05Blind\x10\x07\x12\x0f\n\x0bKillingBlow\x10\
    \x08\x12\n\n\x06Downed\x10\t\x12\x0c\n\x08Breakbar\x10\n\x12\x10\n\x0cOn\
    Activation\x10\x0b\x12\x0e\n\nCR_Unknown\x10\x0c\x12\x0f\n\x0bCR_Unparse\
    d\x10\r\x1a\0*\x8e\x01\n\tEventType\x12\x08\n\x04None\x10\0\x12\x10\n\
    \x0cDirectDamage\x10\x07\x12\x0f\n\x0bBuffApplied\x10\x01\x12\x0f\n\x0bB\
    uffRemoved\x10\x02\x12\x10\n\x0cStateChanged\x10\x03\x12\x0f\n\x0bET_Unp\
    arsed\x10\x04\x12\x0e\n\nActivation\x10\x05\x12\x0e\n\nBuffDamage\x10\
    \x06\x1a\0*\xd1\x02\n\x0bStateChange\x12\x08\n\x04NONE\x10\0\x12\x0f\n\
    \x0bENTERCOMBAT\x10\x01\x12\x0e\n\nEXITCOMBAT\x10\x02\x12\x0c\n\x08CHANG\
    EUP\x10\x03\x12\x0e\n\nCHANGEDEAD\x10\x04\x12\x0e\n\nCHANGEDOWN\x10\x05\
    \x12\x0c\n\x08LOGSTART\x10\t\x12\n\n\x06LOGEND\x10\n\x12\x0c\n\x08WEAPSW\
    AP\x10\x0b\x12\n\n\x06REWARD\x10\x11\x12\x0f\n\x0bBUFFINITIAL\x10\x12\
    \x12\x0e\n\nTEAMCHANGE\x10\x13\x12\x0f\n\x0bSTACKACTIVE\x10\x18\x12\x0e\
    \n\nSTACKRESET\x10\x19\x12\t\n\x05GUILD\x10\x1a\x12\x07\n\x03TAG\x10!\
    \x12\r\n\tSTATRESET\x10#\x12\r\n\tEXTENSION\x10$\x12\x0e\n\nAPIDELAYED\
    \x10%\x12\x11\n\rINSTANCESTART\x10&\x12\x0b\n\x07UNKNOWN\x10'\x12\x0f\n\
    \x0bSC_UNPARSED\x10(\x1a\0*\x92\x01\n\x10CombatActivation\x12\x0b\n\x07C\
    A_NONE\x10\0\x12\t\n\x05START\x10\x01\x12\x14\n\x10QUICKNESS_UNUSED\x10\
    \x02\x12\x0f\n\x0bCANCEL_FIRE\x10\x03\x12\x11\n\rCANCEL_CANCEL\x10\x04\
    \x12\t\n\x05RESET\x10\x05\x12\x0e\n\nCA_UNKNOWN\x10\x06\x12\x0f\n\x0bCA_\
    UNPARSED\x10\x07\x1a\0*Q\n\x0eBuffRemoveType\x12\x0b\n\x07BR_None\x10\0\
    \x12\x07\n\x03All\x10\x01\x12\n\n\x06Single\x10\x02\x12\n\n\x06Manual\
    \x10\x03\x12\x0f\n\x0bBR_Unparsed\x10\x04\x1a\0*`\n\tWeaponSet\x12\x0f\n\
    \x0bWS_Unparsed\x10\0\x12\x0f\n\x0bWaterSetOne\x10\x01\x12\x0f\n\x0bWate\
    rSetTwo\x10\x02\x12\x0e\n\nLandSetOne\x10\x05\x12\x0e\n\nLandSetTwo\x10\
    \x06\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
