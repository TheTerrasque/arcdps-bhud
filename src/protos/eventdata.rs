// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `eventdata.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct ImGuiEvent {
    // message fields
    pub UiState: UiState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImGuiEvent {
    fn default() -> &'a ImGuiEvent {
        <ImGuiEvent as ::protobuf::Message>::default_instance()
    }
}

impl ImGuiEvent {
    pub fn new() -> ImGuiEvent {
        ::std::default::Default::default()
    }

    // .UiState UiState = 1;


    pub fn get_UiState(&self) -> UiState {
        self.UiState
    }
    pub fn clear_UiState(&mut self) {
        self.UiState = UiState::Default;
    }

    // Param is passed by value, moved
    pub fn set_UiState(&mut self, v: UiState) {
        self.UiState = v;
    }
}

impl ::protobuf::Message for ImGuiEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.UiState, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.UiState != UiState::Default {
            my_size += ::protobuf::rt::enum_size(1, self.UiState);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.UiState != UiState::Default {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.UiState))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImGuiEvent {
        ImGuiEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UiState>>(
                "UiState",
                |m: &ImGuiEvent| { &m.UiState },
                |m: &mut ImGuiEvent| { &mut m.UiState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImGuiEvent>(
                "ImGuiEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImGuiEvent {
        static instance: ::protobuf::rt::LazyV2<ImGuiEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImGuiEvent::new)
    }
}

impl ::protobuf::Clear for ImGuiEvent {
    fn clear(&mut self) {
        self.UiState = UiState::Default;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImGuiEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImGuiEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Actor {
    // message fields
    pub name: ::std::string::String,
    pub id: u32,
    pub prof: u32,
    pub elite: u32,
    pub self_: u32,
    pub team: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Actor {
    fn default() -> &'a Actor {
        <Actor as ::protobuf::Message>::default_instance()
    }
}

impl Actor {
    pub fn new() -> Actor {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint32 id = 2;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // uint32 prof = 3;


    pub fn get_prof(&self) -> u32 {
        self.prof
    }
    pub fn clear_prof(&mut self) {
        self.prof = 0;
    }

    // Param is passed by value, moved
    pub fn set_prof(&mut self, v: u32) {
        self.prof = v;
    }

    // uint32 elite = 4;


    pub fn get_elite(&self) -> u32 {
        self.elite
    }
    pub fn clear_elite(&mut self) {
        self.elite = 0;
    }

    // Param is passed by value, moved
    pub fn set_elite(&mut self, v: u32) {
        self.elite = v;
    }

    // uint32 self_ = 5;


    pub fn get_self_(&self) -> u32 {
        self.self_
    }
    pub fn clear_self_(&mut self) {
        self.self_ = 0;
    }

    // Param is passed by value, moved
    pub fn set_self_(&mut self, v: u32) {
        self.self_ = v;
    }

    // uint32 team = 6;


    pub fn get_team(&self) -> u32 {
        self.team
    }
    pub fn clear_team(&mut self) {
        self.team = 0;
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = v;
    }
}

impl ::protobuf::Message for Actor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prof = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.elite = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.self_ = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prof != 0 {
            my_size += ::protobuf::rt::value_size(3, self.prof, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.elite != 0 {
            my_size += ::protobuf::rt::value_size(4, self.elite, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.self_ != 0 {
            my_size += ::protobuf::rt::value_size(5, self.self_, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.team != 0 {
            my_size += ::protobuf::rt::value_size(6, self.team, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.id != 0 {
            os.write_uint32(2, self.id)?;
        }
        if self.prof != 0 {
            os.write_uint32(3, self.prof)?;
        }
        if self.elite != 0 {
            os.write_uint32(4, self.elite)?;
        }
        if self.self_ != 0 {
            os.write_uint32(5, self.self_)?;
        }
        if self.team != 0 {
            os.write_uint32(6, self.team)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Actor {
        Actor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Actor| { &m.name },
                |m: &mut Actor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Actor| { &m.id },
                |m: &mut Actor| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "prof",
                |m: &Actor| { &m.prof },
                |m: &mut Actor| { &mut m.prof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "elite",
                |m: &Actor| { &m.elite },
                |m: &mut Actor| { &mut m.elite },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "self_",
                |m: &Actor| { &m.self_ },
                |m: &mut Actor| { &mut m.self_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "team",
                |m: &Actor| { &m.team },
                |m: &mut Actor| { &mut m.team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Actor>(
                "Actor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Actor {
        static instance: ::protobuf::rt::LazyV2<Actor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Actor::new)
    }
}

impl ::protobuf::Clear for Actor {
    fn clear(&mut self) {
        self.name.clear();
        self.id = 0;
        self.prof = 0;
        self.elite = 0;
        self.self_ = 0;
        self.team = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Actor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Actor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CombatEvent {
    // message fields
    pub time: u64,
    pub src_agent: u32,
    pub dst_agent: u32,
    pub value: i32,
    pub buff_dmg: i32,
    pub overstack_value: u32,
    pub skillid: u32,
    pub src_instid: u32,
    pub dst_instid: u32,
    pub src_master_instid: u32,
    pub iff: u32,
    pub buff: u32,
    pub result: u32,
    pub is_activation: u32,
    pub is_buffremove: u32,
    pub is_ninety: u32,
    pub is_fifty: u32,
    pub is_moving: u32,
    pub is_statechange: u32,
    pub is_flanking: u32,
    pub is_shields: u32,
    pub is_offcycle: u32,
    pub pad61: u32,
    pub pad62: u32,
    pub pad63: u32,
    pub pad64: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CombatEvent {
    fn default() -> &'a CombatEvent {
        <CombatEvent as ::protobuf::Message>::default_instance()
    }
}

impl CombatEvent {
    pub fn new() -> CombatEvent {
        ::std::default::Default::default()
    }

    // uint64 time = 1;


    pub fn get_time(&self) -> u64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u64) {
        self.time = v;
    }

    // uint32 src_agent = 2;


    pub fn get_src_agent(&self) -> u32 {
        self.src_agent
    }
    pub fn clear_src_agent(&mut self) {
        self.src_agent = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_agent(&mut self, v: u32) {
        self.src_agent = v;
    }

    // uint32 dst_agent = 3;


    pub fn get_dst_agent(&self) -> u32 {
        self.dst_agent
    }
    pub fn clear_dst_agent(&mut self) {
        self.dst_agent = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_agent(&mut self, v: u32) {
        self.dst_agent = v;
    }

    // int32 value = 4;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    // int32 buff_dmg = 5;


    pub fn get_buff_dmg(&self) -> i32 {
        self.buff_dmg
    }
    pub fn clear_buff_dmg(&mut self) {
        self.buff_dmg = 0;
    }

    // Param is passed by value, moved
    pub fn set_buff_dmg(&mut self, v: i32) {
        self.buff_dmg = v;
    }

    // uint32 overstack_value = 6;


    pub fn get_overstack_value(&self) -> u32 {
        self.overstack_value
    }
    pub fn clear_overstack_value(&mut self) {
        self.overstack_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_overstack_value(&mut self, v: u32) {
        self.overstack_value = v;
    }

    // uint32 skillid = 7;


    pub fn get_skillid(&self) -> u32 {
        self.skillid
    }
    pub fn clear_skillid(&mut self) {
        self.skillid = 0;
    }

    // Param is passed by value, moved
    pub fn set_skillid(&mut self, v: u32) {
        self.skillid = v;
    }

    // uint32 src_instid = 8;


    pub fn get_src_instid(&self) -> u32 {
        self.src_instid
    }
    pub fn clear_src_instid(&mut self) {
        self.src_instid = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_instid(&mut self, v: u32) {
        self.src_instid = v;
    }

    // uint32 dst_instid = 9;


    pub fn get_dst_instid(&self) -> u32 {
        self.dst_instid
    }
    pub fn clear_dst_instid(&mut self) {
        self.dst_instid = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_instid(&mut self, v: u32) {
        self.dst_instid = v;
    }

    // uint32 src_master_instid = 10;


    pub fn get_src_master_instid(&self) -> u32 {
        self.src_master_instid
    }
    pub fn clear_src_master_instid(&mut self) {
        self.src_master_instid = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_master_instid(&mut self, v: u32) {
        self.src_master_instid = v;
    }

    // uint32 iff = 11;


    pub fn get_iff(&self) -> u32 {
        self.iff
    }
    pub fn clear_iff(&mut self) {
        self.iff = 0;
    }

    // Param is passed by value, moved
    pub fn set_iff(&mut self, v: u32) {
        self.iff = v;
    }

    // uint32 buff = 12;


    pub fn get_buff(&self) -> u32 {
        self.buff
    }
    pub fn clear_buff(&mut self) {
        self.buff = 0;
    }

    // Param is passed by value, moved
    pub fn set_buff(&mut self, v: u32) {
        self.buff = v;
    }

    // uint32 result = 13;


    pub fn get_result(&self) -> u32 {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = 0;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = v;
    }

    // uint32 is_activation = 14;


    pub fn get_is_activation(&self) -> u32 {
        self.is_activation
    }
    pub fn clear_is_activation(&mut self) {
        self.is_activation = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_activation(&mut self, v: u32) {
        self.is_activation = v;
    }

    // uint32 is_buffremove = 15;


    pub fn get_is_buffremove(&self) -> u32 {
        self.is_buffremove
    }
    pub fn clear_is_buffremove(&mut self) {
        self.is_buffremove = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_buffremove(&mut self, v: u32) {
        self.is_buffremove = v;
    }

    // uint32 is_ninety = 16;


    pub fn get_is_ninety(&self) -> u32 {
        self.is_ninety
    }
    pub fn clear_is_ninety(&mut self) {
        self.is_ninety = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_ninety(&mut self, v: u32) {
        self.is_ninety = v;
    }

    // uint32 is_fifty = 17;


    pub fn get_is_fifty(&self) -> u32 {
        self.is_fifty
    }
    pub fn clear_is_fifty(&mut self) {
        self.is_fifty = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_fifty(&mut self, v: u32) {
        self.is_fifty = v;
    }

    // uint32 is_moving = 18;


    pub fn get_is_moving(&self) -> u32 {
        self.is_moving
    }
    pub fn clear_is_moving(&mut self) {
        self.is_moving = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_moving(&mut self, v: u32) {
        self.is_moving = v;
    }

    // uint32 is_statechange = 19;


    pub fn get_is_statechange(&self) -> u32 {
        self.is_statechange
    }
    pub fn clear_is_statechange(&mut self) {
        self.is_statechange = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_statechange(&mut self, v: u32) {
        self.is_statechange = v;
    }

    // uint32 is_flanking = 20;


    pub fn get_is_flanking(&self) -> u32 {
        self.is_flanking
    }
    pub fn clear_is_flanking(&mut self) {
        self.is_flanking = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_flanking(&mut self, v: u32) {
        self.is_flanking = v;
    }

    // uint32 is_shields = 21;


    pub fn get_is_shields(&self) -> u32 {
        self.is_shields
    }
    pub fn clear_is_shields(&mut self) {
        self.is_shields = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_shields(&mut self, v: u32) {
        self.is_shields = v;
    }

    // uint32 is_offcycle = 22;


    pub fn get_is_offcycle(&self) -> u32 {
        self.is_offcycle
    }
    pub fn clear_is_offcycle(&mut self) {
        self.is_offcycle = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_offcycle(&mut self, v: u32) {
        self.is_offcycle = v;
    }

    // uint32 pad61 = 23;


    pub fn get_pad61(&self) -> u32 {
        self.pad61
    }
    pub fn clear_pad61(&mut self) {
        self.pad61 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad61(&mut self, v: u32) {
        self.pad61 = v;
    }

    // uint32 pad62 = 24;


    pub fn get_pad62(&self) -> u32 {
        self.pad62
    }
    pub fn clear_pad62(&mut self) {
        self.pad62 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad62(&mut self, v: u32) {
        self.pad62 = v;
    }

    // uint32 pad63 = 25;


    pub fn get_pad63(&self) -> u32 {
        self.pad63
    }
    pub fn clear_pad63(&mut self) {
        self.pad63 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad63(&mut self, v: u32) {
        self.pad63 = v;
    }

    // uint32 pad64 = 26;


    pub fn get_pad64(&self) -> u32 {
        self.pad64
    }
    pub fn clear_pad64(&mut self) {
        self.pad64 = 0;
    }

    // Param is passed by value, moved
    pub fn set_pad64(&mut self, v: u32) {
        self.pad64 = v;
    }
}

impl ::protobuf::Message for CombatEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_agent = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_agent = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.buff_dmg = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.overstack_value = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.skillid = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_instid = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_instid = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_master_instid = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.iff = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buff = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_activation = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_buffremove = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_ninety = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_fifty = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_moving = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_statechange = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_flanking = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_shields = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_offcycle = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad61 = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad62 = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad63 = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pad64 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_agent != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_agent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_agent != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dst_agent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(4, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.buff_dmg != 0 {
            my_size += ::protobuf::rt::value_size(5, self.buff_dmg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.overstack_value != 0 {
            my_size += ::protobuf::rt::value_size(6, self.overstack_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.skillid != 0 {
            my_size += ::protobuf::rt::value_size(7, self.skillid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_instid != 0 {
            my_size += ::protobuf::rt::value_size(8, self.src_instid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_instid != 0 {
            my_size += ::protobuf::rt::value_size(9, self.dst_instid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_master_instid != 0 {
            my_size += ::protobuf::rt::value_size(10, self.src_master_instid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.iff != 0 {
            my_size += ::protobuf::rt::value_size(11, self.iff, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.buff != 0 {
            my_size += ::protobuf::rt::value_size(12, self.buff, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.result != 0 {
            my_size += ::protobuf::rt::value_size(13, self.result, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_activation != 0 {
            my_size += ::protobuf::rt::value_size(14, self.is_activation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_buffremove != 0 {
            my_size += ::protobuf::rt::value_size(15, self.is_buffremove, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_ninety != 0 {
            my_size += ::protobuf::rt::value_size(16, self.is_ninety, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_fifty != 0 {
            my_size += ::protobuf::rt::value_size(17, self.is_fifty, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_moving != 0 {
            my_size += ::protobuf::rt::value_size(18, self.is_moving, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_statechange != 0 {
            my_size += ::protobuf::rt::value_size(19, self.is_statechange, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_flanking != 0 {
            my_size += ::protobuf::rt::value_size(20, self.is_flanking, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_shields != 0 {
            my_size += ::protobuf::rt::value_size(21, self.is_shields, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_offcycle != 0 {
            my_size += ::protobuf::rt::value_size(22, self.is_offcycle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad61 != 0 {
            my_size += ::protobuf::rt::value_size(23, self.pad61, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad62 != 0 {
            my_size += ::protobuf::rt::value_size(24, self.pad62, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad63 != 0 {
            my_size += ::protobuf::rt::value_size(25, self.pad63, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pad64 != 0 {
            my_size += ::protobuf::rt::value_size(26, self.pad64, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0 {
            os.write_uint64(1, self.time)?;
        }
        if self.src_agent != 0 {
            os.write_uint32(2, self.src_agent)?;
        }
        if self.dst_agent != 0 {
            os.write_uint32(3, self.dst_agent)?;
        }
        if self.value != 0 {
            os.write_int32(4, self.value)?;
        }
        if self.buff_dmg != 0 {
            os.write_int32(5, self.buff_dmg)?;
        }
        if self.overstack_value != 0 {
            os.write_uint32(6, self.overstack_value)?;
        }
        if self.skillid != 0 {
            os.write_uint32(7, self.skillid)?;
        }
        if self.src_instid != 0 {
            os.write_uint32(8, self.src_instid)?;
        }
        if self.dst_instid != 0 {
            os.write_uint32(9, self.dst_instid)?;
        }
        if self.src_master_instid != 0 {
            os.write_uint32(10, self.src_master_instid)?;
        }
        if self.iff != 0 {
            os.write_uint32(11, self.iff)?;
        }
        if self.buff != 0 {
            os.write_uint32(12, self.buff)?;
        }
        if self.result != 0 {
            os.write_uint32(13, self.result)?;
        }
        if self.is_activation != 0 {
            os.write_uint32(14, self.is_activation)?;
        }
        if self.is_buffremove != 0 {
            os.write_uint32(15, self.is_buffremove)?;
        }
        if self.is_ninety != 0 {
            os.write_uint32(16, self.is_ninety)?;
        }
        if self.is_fifty != 0 {
            os.write_uint32(17, self.is_fifty)?;
        }
        if self.is_moving != 0 {
            os.write_uint32(18, self.is_moving)?;
        }
        if self.is_statechange != 0 {
            os.write_uint32(19, self.is_statechange)?;
        }
        if self.is_flanking != 0 {
            os.write_uint32(20, self.is_flanking)?;
        }
        if self.is_shields != 0 {
            os.write_uint32(21, self.is_shields)?;
        }
        if self.is_offcycle != 0 {
            os.write_uint32(22, self.is_offcycle)?;
        }
        if self.pad61 != 0 {
            os.write_uint32(23, self.pad61)?;
        }
        if self.pad62 != 0 {
            os.write_uint32(24, self.pad62)?;
        }
        if self.pad63 != 0 {
            os.write_uint32(25, self.pad63)?;
        }
        if self.pad64 != 0 {
            os.write_uint32(26, self.pad64)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CombatEvent {
        CombatEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "time",
                |m: &CombatEvent| { &m.time },
                |m: &mut CombatEvent| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "src_agent",
                |m: &CombatEvent| { &m.src_agent },
                |m: &mut CombatEvent| { &mut m.src_agent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dst_agent",
                |m: &CombatEvent| { &m.dst_agent },
                |m: &mut CombatEvent| { &mut m.dst_agent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &CombatEvent| { &m.value },
                |m: &mut CombatEvent| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "buff_dmg",
                |m: &CombatEvent| { &m.buff_dmg },
                |m: &mut CombatEvent| { &mut m.buff_dmg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "overstack_value",
                |m: &CombatEvent| { &m.overstack_value },
                |m: &mut CombatEvent| { &mut m.overstack_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "skillid",
                |m: &CombatEvent| { &m.skillid },
                |m: &mut CombatEvent| { &mut m.skillid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "src_instid",
                |m: &CombatEvent| { &m.src_instid },
                |m: &mut CombatEvent| { &mut m.src_instid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dst_instid",
                |m: &CombatEvent| { &m.dst_instid },
                |m: &mut CombatEvent| { &mut m.dst_instid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "src_master_instid",
                |m: &CombatEvent| { &m.src_master_instid },
                |m: &mut CombatEvent| { &mut m.src_master_instid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "iff",
                |m: &CombatEvent| { &m.iff },
                |m: &mut CombatEvent| { &mut m.iff },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "buff",
                |m: &CombatEvent| { &m.buff },
                |m: &mut CombatEvent| { &mut m.buff },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CombatEvent| { &m.result },
                |m: &mut CombatEvent| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_activation",
                |m: &CombatEvent| { &m.is_activation },
                |m: &mut CombatEvent| { &mut m.is_activation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_buffremove",
                |m: &CombatEvent| { &m.is_buffremove },
                |m: &mut CombatEvent| { &mut m.is_buffremove },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_ninety",
                |m: &CombatEvent| { &m.is_ninety },
                |m: &mut CombatEvent| { &mut m.is_ninety },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_fifty",
                |m: &CombatEvent| { &m.is_fifty },
                |m: &mut CombatEvent| { &mut m.is_fifty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_moving",
                |m: &CombatEvent| { &m.is_moving },
                |m: &mut CombatEvent| { &mut m.is_moving },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_statechange",
                |m: &CombatEvent| { &m.is_statechange },
                |m: &mut CombatEvent| { &mut m.is_statechange },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_flanking",
                |m: &CombatEvent| { &m.is_flanking },
                |m: &mut CombatEvent| { &mut m.is_flanking },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_shields",
                |m: &CombatEvent| { &m.is_shields },
                |m: &mut CombatEvent| { &mut m.is_shields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_offcycle",
                |m: &CombatEvent| { &m.is_offcycle },
                |m: &mut CombatEvent| { &mut m.is_offcycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad61",
                |m: &CombatEvent| { &m.pad61 },
                |m: &mut CombatEvent| { &mut m.pad61 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad62",
                |m: &CombatEvent| { &m.pad62 },
                |m: &mut CombatEvent| { &mut m.pad62 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad63",
                |m: &CombatEvent| { &m.pad63 },
                |m: &mut CombatEvent| { &mut m.pad63 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pad64",
                |m: &CombatEvent| { &m.pad64 },
                |m: &mut CombatEvent| { &mut m.pad64 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CombatEvent>(
                "CombatEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CombatEvent {
        static instance: ::protobuf::rt::LazyV2<CombatEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CombatEvent::new)
    }
}

impl ::protobuf::Clear for CombatEvent {
    fn clear(&mut self) {
        self.time = 0;
        self.src_agent = 0;
        self.dst_agent = 0;
        self.value = 0;
        self.buff_dmg = 0;
        self.overstack_value = 0;
        self.skillid = 0;
        self.src_instid = 0;
        self.dst_instid = 0;
        self.src_master_instid = 0;
        self.iff = 0;
        self.buff = 0;
        self.result = 0;
        self.is_activation = 0;
        self.is_buffremove = 0;
        self.is_ninety = 0;
        self.is_fifty = 0;
        self.is_moving = 0;
        self.is_statechange = 0;
        self.is_flanking = 0;
        self.is_shields = 0;
        self.is_offcycle = 0;
        self.pad61 = 0;
        self.pad62 = 0;
        self.pad63 = 0;
        self.pad64 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CombatEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CombatMessage {
    // message fields
    pub combat_type: CombatType,
    pub combat_event: ::protobuf::SingularPtrField<CombatEvent>,
    pub src_actor: ::protobuf::SingularPtrField<Actor>,
    pub dst_actor: ::protobuf::SingularPtrField<Actor>,
    pub skillname: ::std::string::String,
    pub id: u64,
    pub revision: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CombatMessage {
    fn default() -> &'a CombatMessage {
        <CombatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CombatMessage {
    pub fn new() -> CombatMessage {
        ::std::default::Default::default()
    }

    // .CombatType combat_type = 1;


    pub fn get_combat_type(&self) -> CombatType {
        self.combat_type
    }
    pub fn clear_combat_type(&mut self) {
        self.combat_type = CombatType::Area;
    }

    // Param is passed by value, moved
    pub fn set_combat_type(&mut self, v: CombatType) {
        self.combat_type = v;
    }

    // .CombatEvent combat_event = 2;


    pub fn get_combat_event(&self) -> &CombatEvent {
        self.combat_event.as_ref().unwrap_or_else(|| <CombatEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_combat_event(&mut self) {
        self.combat_event.clear();
    }

    pub fn has_combat_event(&self) -> bool {
        self.combat_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combat_event(&mut self, v: CombatEvent) {
        self.combat_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_combat_event(&mut self) -> &mut CombatEvent {
        if self.combat_event.is_none() {
            self.combat_event.set_default();
        }
        self.combat_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_combat_event(&mut self) -> CombatEvent {
        self.combat_event.take().unwrap_or_else(|| CombatEvent::new())
    }

    // .Actor src_actor = 3;


    pub fn get_src_actor(&self) -> &Actor {
        self.src_actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_src_actor(&mut self) {
        self.src_actor.clear();
    }

    pub fn has_src_actor(&self) -> bool {
        self.src_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_actor(&mut self, v: Actor) {
        self.src_actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_actor(&mut self) -> &mut Actor {
        if self.src_actor.is_none() {
            self.src_actor.set_default();
        }
        self.src_actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_actor(&mut self) -> Actor {
        self.src_actor.take().unwrap_or_else(|| Actor::new())
    }

    // .Actor dst_actor = 4;


    pub fn get_dst_actor(&self) -> &Actor {
        self.dst_actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dst_actor(&mut self) {
        self.dst_actor.clear();
    }

    pub fn has_dst_actor(&self) -> bool {
        self.dst_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_actor(&mut self, v: Actor) {
        self.dst_actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_actor(&mut self) -> &mut Actor {
        if self.dst_actor.is_none() {
            self.dst_actor.set_default();
        }
        self.dst_actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_actor(&mut self) -> Actor {
        self.dst_actor.take().unwrap_or_else(|| Actor::new())
    }

    // string skillname = 5;


    pub fn get_skillname(&self) -> &str {
        &self.skillname
    }
    pub fn clear_skillname(&mut self) {
        self.skillname.clear();
    }

    // Param is passed by value, moved
    pub fn set_skillname(&mut self, v: ::std::string::String) {
        self.skillname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_skillname(&mut self) -> &mut ::std::string::String {
        &mut self.skillname
    }

    // Take field
    pub fn take_skillname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.skillname, ::std::string::String::new())
    }

    // uint64 id = 6;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint64 revision = 7;


    pub fn get_revision(&self) -> u64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u64) {
        self.revision = v;
    }
}

impl ::protobuf::Message for CombatMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.combat_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.src_actor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dst_actor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.combat_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.combat_event)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_actor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst_actor)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.skillname)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.combat_type != CombatType::Area {
            my_size += ::protobuf::rt::enum_size(1, self.combat_type);
        }
        if let Some(ref v) = self.combat_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.src_actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst_actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.skillname.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.skillname);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(7, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.combat_type != CombatType::Area {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.combat_type))?;
        }
        if let Some(ref v) = self.combat_event.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.src_actor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst_actor.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.skillname.is_empty() {
            os.write_string(5, &self.skillname)?;
        }
        if self.id != 0 {
            os.write_uint64(6, self.id)?;
        }
        if self.revision != 0 {
            os.write_uint64(7, self.revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CombatMessage {
        CombatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CombatType>>(
                "combat_type",
                |m: &CombatMessage| { &m.combat_type },
                |m: &mut CombatMessage| { &mut m.combat_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CombatEvent>>(
                "combat_event",
                |m: &CombatMessage| { &m.combat_event },
                |m: &mut CombatMessage| { &mut m.combat_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "src_actor",
                |m: &CombatMessage| { &m.src_actor },
                |m: &mut CombatMessage| { &mut m.src_actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "dst_actor",
                |m: &CombatMessage| { &m.dst_actor },
                |m: &mut CombatMessage| { &mut m.dst_actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "skillname",
                |m: &CombatMessage| { &m.skillname },
                |m: &mut CombatMessage| { &mut m.skillname },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CombatMessage| { &m.id },
                |m: &mut CombatMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "revision",
                |m: &CombatMessage| { &m.revision },
                |m: &mut CombatMessage| { &mut m.revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CombatMessage>(
                "CombatMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CombatMessage {
        static instance: ::protobuf::rt::LazyV2<CombatMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CombatMessage::new)
    }
}

impl ::protobuf::Clear for CombatMessage {
    fn clear(&mut self) {
        self.combat_type = CombatType::Area;
        self.combat_event.clear();
        self.src_actor.clear();
        self.dst_actor.clear();
        self.skillname.clear();
        self.id = 0;
        self.revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CombatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub imgui_event: ::protobuf::SingularPtrField<ImGuiEvent>,
    pub combat_message: ::protobuf::SingularPtrField<CombatMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // .ImGuiEvent imgui_event = 1;


    pub fn get_imgui_event(&self) -> &ImGuiEvent {
        self.imgui_event.as_ref().unwrap_or_else(|| <ImGuiEvent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_imgui_event(&mut self) {
        self.imgui_event.clear();
    }

    pub fn has_imgui_event(&self) -> bool {
        self.imgui_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imgui_event(&mut self, v: ImGuiEvent) {
        self.imgui_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imgui_event(&mut self) -> &mut ImGuiEvent {
        if self.imgui_event.is_none() {
            self.imgui_event.set_default();
        }
        self.imgui_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_imgui_event(&mut self) -> ImGuiEvent {
        self.imgui_event.take().unwrap_or_else(|| ImGuiEvent::new())
    }

    // .CombatMessage combat_message = 2;


    pub fn get_combat_message(&self) -> &CombatMessage {
        self.combat_message.as_ref().unwrap_or_else(|| <CombatMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_combat_message(&mut self) {
        self.combat_message.clear();
    }

    pub fn has_combat_message(&self) -> bool {
        self.combat_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combat_message(&mut self, v: CombatMessage) {
        self.combat_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_combat_message(&mut self) -> &mut CombatMessage {
        if self.combat_message.is_none() {
            self.combat_message.set_default();
        }
        self.combat_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_combat_message(&mut self) -> CombatMessage {
        self.combat_message.take().unwrap_or_else(|| CombatMessage::new())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.imgui_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.combat_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.imgui_event)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.combat_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.imgui_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.combat_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.imgui_event.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.combat_message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImGuiEvent>>(
                "imgui_event",
                |m: &Event| { &m.imgui_event },
                |m: &mut Event| { &mut m.imgui_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CombatMessage>>(
                "combat_message",
                |m: &Event| { &m.combat_message },
                |m: &mut Event| { &mut m.combat_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                "Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.imgui_event.clear();
        self.combat_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UiState {
    Default = 0,
    CharacterSelectionOrLoading = 1,
}

impl ::protobuf::ProtobufEnum for UiState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UiState> {
        match value {
            0 => ::std::option::Option::Some(UiState::Default),
            1 => ::std::option::Option::Some(UiState::CharacterSelectionOrLoading),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UiState] = &[
            UiState::Default,
            UiState::CharacterSelectionOrLoading,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UiState>("UiState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UiState {
}

impl ::std::default::Default for UiState {
    fn default() -> Self {
        UiState::Default
    }
}

impl ::protobuf::reflect::ProtobufValue for UiState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CombatType {
    Area = 1,
    Local = 2,
}

impl ::protobuf::ProtobufEnum for CombatType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CombatType> {
        match value {
            1 => ::std::option::Option::Some(CombatType::Area),
            2 => ::std::option::Option::Some(CombatType::Local),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CombatType] = &[
            CombatType::Area,
            CombatType::Local,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CombatType>("CombatType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CombatType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CombatType {
    fn default() -> Self {
        CombatType::Area
    }
}

impl ::protobuf::reflect::ProtobufValue for CombatType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0feventdata.proto\"4\n\nImGuiEvent\x12$\n\x07UiState\x18\x01\x20\x01\
    (\x0e2\x08.UiStateR\x07UiStateB\0:\0\"\x8c\x01\n\x05Actor\x12\x14\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04nameB\0\x12\x10\n\x02id\x18\x02\x20\x01(\rR\
    \x02idB\0\x12\x14\n\x04prof\x18\x03\x20\x01(\rR\x04profB\0\x12\x16\n\x05\
    elite\x18\x04\x20\x01(\rR\x05eliteB\0\x12\x15\n\x05self_\x18\x05\x20\x01\
    (\rR\x04selfB\0\x12\x14\n\x04team\x18\x06\x20\x01(\rR\x04teamB\0:\0\"\
    \xac\x06\n\x0bCombatEvent\x12\x14\n\x04time\x18\x01\x20\x01(\x04R\x04tim\
    eB\0\x12\x1d\n\tsrc_agent\x18\x02\x20\x01(\rR\x08srcAgentB\0\x12\x1d\n\t\
    dst_agent\x18\x03\x20\x01(\rR\x08dstAgentB\0\x12\x16\n\x05value\x18\x04\
    \x20\x01(\x05R\x05valueB\0\x12\x1b\n\x08buff_dmg\x18\x05\x20\x01(\x05R\
    \x07buffDmgB\0\x12)\n\x0foverstack_value\x18\x06\x20\x01(\rR\x0eoverstac\
    kValueB\0\x12\x1a\n\x07skillid\x18\x07\x20\x01(\rR\x07skillidB\0\x12\x1f\
    \n\nsrc_instid\x18\x08\x20\x01(\rR\tsrcInstidB\0\x12\x1f\n\ndst_instid\
    \x18\t\x20\x01(\rR\tdstInstidB\0\x12,\n\x11src_master_instid\x18\n\x20\
    \x01(\rR\x0fsrcMasterInstidB\0\x12\x12\n\x03iff\x18\x0b\x20\x01(\rR\x03i\
    ffB\0\x12\x14\n\x04buff\x18\x0c\x20\x01(\rR\x04buffB\0\x12\x18\n\x06resu\
    lt\x18\r\x20\x01(\rR\x06resultB\0\x12%\n\ris_activation\x18\x0e\x20\x01(\
    \rR\x0cisActivationB\0\x12%\n\ris_buffremove\x18\x0f\x20\x01(\rR\x0cisBu\
    ffremoveB\0\x12\x1d\n\tis_ninety\x18\x10\x20\x01(\rR\x08isNinetyB\0\x12\
    \x1b\n\x08is_fifty\x18\x11\x20\x01(\rR\x07isFiftyB\0\x12\x1d\n\tis_movin\
    g\x18\x12\x20\x01(\rR\x08isMovingB\0\x12'\n\x0eis_statechange\x18\x13\
    \x20\x01(\rR\risStatechangeB\0\x12!\n\x0bis_flanking\x18\x14\x20\x01(\rR\
    \nisFlankingB\0\x12\x1f\n\nis_shields\x18\x15\x20\x01(\rR\tisShieldsB\0\
    \x12!\n\x0bis_offcycle\x18\x16\x20\x01(\rR\nisOffcycleB\0\x12\x16\n\x05p\
    ad61\x18\x17\x20\x01(\rR\x05pad61B\0\x12\x16\n\x05pad62\x18\x18\x20\x01(\
    \rR\x05pad62B\0\x12\x16\n\x05pad63\x18\x19\x20\x01(\rR\x05pad63B\0\x12\
    \x16\n\x05pad64\x18\x1a\x20\x01(\rR\x05pad64B\0:\0\"\x92\x02\n\rCombatMe\
    ssage\x12.\n\x0bcombat_type\x18\x01\x20\x01(\x0e2\x0b.CombatTypeR\ncomba\
    tTypeB\0\x121\n\x0ccombat_event\x18\x02\x20\x01(\x0b2\x0c.CombatEventR\
    \x0bcombatEventB\0\x12%\n\tsrc_actor\x18\x03\x20\x01(\x0b2\x06.ActorR\
    \x08srcActorB\0\x12%\n\tdst_actor\x18\x04\x20\x01(\x0b2\x06.ActorR\x08ds\
    tActorB\0\x12\x1e\n\tskillname\x18\x05\x20\x01(\tR\tskillnameB\0\x12\x10\
    \n\x02id\x18\x06\x20\x01(\x04R\x02idB\0\x12\x1c\n\x08revision\x18\x07\
    \x20\x01(\x04R\x08revisionB\0:\0\"r\n\x05Event\x12.\n\x0bimgui_event\x18\
    \x01\x20\x01(\x0b2\x0b.ImGuiEventR\nimguiEventB\0\x127\n\x0ecombat_messa\
    ge\x18\x02\x20\x01(\x0b2\x0e.CombatMessageR\rcombatMessageB\0:\0*9\n\x07\
    UiState\x12\x0b\n\x07Default\x10\0\x12\x1f\n\x1bCharacterSelectionOrLoad\
    ing\x10\x01\x1a\0*#\n\nCombatType\x12\x08\n\x04Area\x10\x01\x12\t\n\x05L\
    ocal\x10\x02\x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
